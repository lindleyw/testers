#!/usr/bin/env perl

use Mojolicious::Lite;

use Mojo::URL;
use Mojo::File;
use Mojo::UserAgent;
use Mojo::DOM;
use v5.22;
use strict;
use warnings;

################################################################

# Can be called as, e.g.,
#   $ perl smoketest update ~/Documents/02packages.details.txt -m rebuild
# to rebuild and reload database from a local file, or:
#   $ perl smoketest update
# to update from the default CPAN location (remote URL)

sub _text_extract {
    my ($module_text) = @_;
        
    my $vals = {}; # populate with a hash slice:
    @{$vals}{qw(name version relative_url)} = split /\s+/, $module_text;
    $vals->{author} = ($vals->{relative_url} =~ m{^./../(\w+)/})[0];
    # Replace text 'undef'
    $vals->{version} = undef if ($vals->{version} eq 'undef');
    return $vals;
}

# use Date::Parse;

my %months = (jan=>1,feb=>2,mar=>3,apr=>4,may=>5,jun=>6,jul=>7,aug=>8,sep=>9,oct=>10,nov=>11,dec=>12);

sub _dom_extract {
    my $module_tgzs = shift;

    my @modules;
    $module_tgzs->each( sub {
                            my $module_node = shift;
                            my $module_info = {};
                            @{$module_info}{qw(author name version)} = ( $module_node->attr('href') =~   # from the URL,
                                                                           m{(\w+)/([^/]+?)-?v?([0-9a-z.]+)?\.tar\.gz}
                                                                         );  # Extract into hash slice
                            $module_info->{name} =~ s/-/::/g;

                            # Extract content and remove any leading whitespace
                            my $module_info_text = $module_node->next_node->content =~ s/\A\s+//r =~ s/\s+\z//r;
                            ($module_info->{size}, my $m_day, my $m_mon, my $m_year) = split(/\s+/, $module_info_text, 4);
                            $module_info->{size} =~ s/^([0-9.])+([kM])/$1*({k=>1024,M=>1024*1024}->{$2})/e;  # Convert human units to octets
                            # use Date::Parse and do str2time() of date for epoch timestamp, or simply put into format SQLite understands:
                            $module_info->{released} = sprintf('%4d-%02d-%02d', $m_year, $months{lc($m_mon)}, $m_day);
                            push @modules, $module_info;
                        } );
    return Mojo::Collection->new(@modules);
}

sub update {
    my ($self, $source) = @_;

    my $module_list;
    my $module_dom;

    # If no source specified, load default remote module list
    my $source_url = Mojo::URL->new($source // $self->app->config->{cpan_testers});
    # 'http://cpan.cpantesters.org/');

    if ($source_url->protocol || $source_url->host) {
        # Remote file
        unless (length($source_url->path) > 1) {  # no path, or '/'
            push @{$source_url->path->parts}, ( 'modules',
                                                # '01modules.index.html'
                                                '02packages.details.txt'
                                              );
        }
        my $ua = Mojo::UserAgent->new();
        $module_list = $ua->get($source_url)->result;
        die "Can't download modules list: ".$module_list->message
        unless $module_list->is_success;
        $module_list = $module_list->body;   # ->dom;   # DOM for HTML
    } else {
        # Local file
        $module_list = Mojo::File->new( $source)->slurp;
        die "No module list file" unless length($module_list);
        $module_dom = Mojo::DOM->new($module_list) if ($module_list =~ /<html/i);
    }

    my $module_tgzs;
    if (defined $module_dom) {
        $module_tgzs = _dom_extract($module_dom->find('a[href$=".tar.gz"]'));
    } else {
        # Extract from text file, skipping header, with header/body as SMTP message
        my $header = 1;
        $module_tgzs = Mojo::Collection->new (
                                              map {
                                                  if ($header) {
                                                      $header = $_ !~ /^$/;  # false once we reach blank line
                                                      ();                    # and skip this
                                                  } else {
                                                      _text_extract($_);
                                                  }
                                              } ( split (/\n/, $module_list ) )
                                             );
    }
    $module_tgzs->each(sub { $self->app->db
                             ->query('INSERT OR REPLACE INTO modules(name, version, released, author, relative_url) '.
                                     'VALUES (?,?,?,?,?)',
                                     $_->{name}, $_->{version}, $_->{released}, $_->{author}, $_->{relative_url});
                         });
    return $module_tgzs->size;
}

################################################################

sub enable_recent {
    # Get the list of most recently updated modules from source; default to
    # http://cpan.cpantesters.org/modules/01modules.mtime.html
    my ($self, $info, $source) = @_;

    my $source_url = Mojo::URL->new($source // $self->app->config->{cpan_testers} );
                                    # 'http://cpan.cpantesters.org/');
    push @{$source_url->path->parts}, 'modules', '01modules.mtime.html';

    my $ua = Mojo::UserAgent->new();
    my $module_dom = $ua->get($source_url)->result->dom;

    # Create a list of modules
    my $modules = _dom_extract($module_dom->find('a[href$=".tar.gz"]'));

    $modules->each(sub { $self->app->db
                         ->query('INSERT OR REPLACE INTO modules(name, version, released, author, relative_url) '.
                                 'VALUES (?,?,?,?,?)',
                                 $_->{name}, $_->{version}, $_->{released}, $_->{author}, $_->{relative_url});
                     });

    # Convert list to a regex which selects exactly those modules
    my $regex = "^(?x:\n.^  # never matches, only purpose is to let things align nicely\n" .
      '    # Recent modules list from ' . $source_url . "\n    |".
      $modules->map( sub { $_->{name} . '  # Version ' . $_->{version} . '  ' . $_->{released} })->join("\n   |")     
      . "\n)";
    # Save regex in module_flags table
    my $saved = $self->app->db->query('INSERT OR REPLACE INTO module_flags (priority, origin, author, disable, regex) '.
                                      'VALUES (?,?,?,?,?)',
                                      $info->{priority}, $info->{reason}, $info->{author}, $info->{disabled} // 0, $regex
                                     );
    return 1;
    
}

################################################################

# Find CPAN in the list of modules (it's currently under ANDK's directory)
# Get the current revision's list of disabled modules and use that to refresh the disabled list

# When relative_url is 'A/AN/ANDK/CPAN-2.16.tar.gz' name is CPAN, version is 2.16 --
# Fetch https://st.aticpan.org/source/ANDK/CPAN-2.16/distroprefs/01.DISABLED.yml

package cpan_wrapper {
    use CPAN;           # Must be inside a module, not the main program, because we don't want to *run* cpan!
    sub version {
        return $CPAN::VERSION;
    }
};

use YAML;

sub disable {
    my ($self, $source) = @_;

    # Load a local or remote copy of a regex which will be applied against the list of modules,
    # to disable (or enable) them.

    # If no source specified, load default remote file
    my $source_url = Mojo::URL->new($source // $self->app->config->{cpan_source});
    my $disabled_list;
    my ($priority, $author, $version, $reason);

    if ($source_url->protocol || $source_url->host) {
        # Remote file

        my $module = $self->app->db->query('SELECT * FROM modules WHERE NAME=? ORDER BY added DESC LIMIT 1',
                                           'CPAN');
        return undef unless defined $module;
        $module = $module->hashes->first;
        return undef unless defined $module;
        ($author, $version) = @{$module}{qw(author version)};

        if ($version ne cpan_wrapper::version()) {
            warn "Our cpan=$CPAN::VERSION but remote is $version";
        }

        unless ($source_url->path  =~ /\.\w+/) { # If just a path, without a filename+extension: use default
            push @{$source_url->path->parts}, ( $author,
                                                'CPAN-' . $version,
                                                'distroprefs',
                                                '01.DISABLED.yml'
                                              );
            $source_url->path->trailing_slash(0);
        }
        $reason = "${author}/CPAN-${version}";
        my $ua = Mojo::UserAgent->new();
        $disabled_list = $ua->get($source_url)->result;
        die "Can't download disabled list: ".$disabled_list->message
        unless $disabled_list->is_success;
        $disabled_list = $disabled_list->body;
        $priority = 100;        # Default for remote file
    } else {
        # Local file
        $reason = $source;
        $priority = 50;         # Default for local
        $disabled_list = Mojo::File->new( $source)->slurp;
        die "No module list file" unless length($disabled_list);
    }

    my $matchfile = YAML::Load($disabled_list);
        
    # save as meta-information in the Modules list
    my $saved = $self->app->db->query('INSERT OR REPLACE INTO module_flags (priority, origin, author, disable, regex) '.
                                      'VALUES (?,?,?,?,?)',
                                      $priority, $reason, $author, $matchfile->{disabled}, $matchfile->{match}{distribution}
                                     );
        
    1;

}

sub apply {
    my ($self) = @_;


    # For each available enable/list, apply in priority order
    my $regex_list = $self->app->db->query('SELECT * FROM module_flags ORDER BY priority DESC, added DESC');
    return undef unless defined $regex_list;
    my $regexes = Mojo::Collection->new($regex_list->hashes);
    
    # TODO: Can we use the "Recent" list as an Enabled list?
    # And then for example, apply "disable .*" and then "enable the recent modules" and then apply the disabled lists?

    # TODO: Put the above recipe in the config file


    # TODO:  Possibly create a job list as follows
    #   - disable all modules
    #   - enable a few modules:
    #       - the most recent modules (according to CPAN)
    #       - (or) all modules with 'added' timestamp less than 'x'
    #         seconds ago in our database
    #   - disable according to CPAN globally
    #   - disable according to a local file
    #   - disable any module we have tested less than 'y' seconds ago

    # .. For each module:

        # foreach (...) {
        #     if ( $module =~ $dist_regex ) {
        #         # Disable (or enable, if disabled=0 in matchfile)
        #         ... = $matchfile->{disabled};
        #         UPDATE modules SET disabled_by = $reason
        #     }
        # }

        
}

################################################################
################################################################
################################################################

package main::Command::update {
    use Mojo::Base 'Mojolicious::Command';

    sub run {
        # ; my ($self) = @_; use Data::Dumper; print STDERR Dumper($self->app->config);
        return ::update(@_);
    }
};

################################################################

package main::Command::disable {
    use Mojo::Base 'Mojolicious::Command';

    sub run {

        return ::disable(@_);
    }

};

################################################################

package main::Command::enable_recent {
    use Mojo::Base 'Mojolicious::Command';

    sub run {
        return ::enable_recent(@_);
    }
};

################################################################

# Apply the enable/disable list(s)
#

package main::Command::apply {
    use Mojo::Base 'Mojolicious::Command';

    sub run {
        my ($self, @selected_modules) = @_;

        return ::apply(@_);
    }
}

################################################################

# Create Test jobs for one module, or for all enabled modules
#

package main::Command::create {
    use Mojo::Base 'Mojolicious::Command';

    sub run {
        my ($self, @selected_modules) = @_;

        
    }
    
}

################################################################
################################################################
################################################################

package Smoker::Database {

    use Mojo::Base -base;
    use Mojo::File;

    use Mojo::SQLite;
    # use Mojo::Pg;         # Alternate databases possible via connection string

    use SQL::Abstract::More;

    has 'database';
    has 'rebuild';     # Flag to rebuild database.  Useful for debugging or reprovisioning
    has 'sql' => sub { # Set during instantiation; or, create object
        my ($self) = @_;
        if (defined $self->database) {
            Mojo::SQLite->new('sqlite:' . $self->database);
        }
    };

    sub new {
        my $class = shift;
        my $self = $class->SUPER::new(@_);

        $self->sql->abstract(SQL::Abstract::More->new());

        $self->sql->migrations->name('smoker_migrations')->from_data('main', 'sqlite_migrations');

        $self->sql->migrations->tap(sub { $self->rebuild and $_->migrate(0) })->migrate;
        my $jmode = $self->sql->db->query('PRAGMA journal_mode=WAL;');
        if ($jmode->arrays->[0]->[0] ne 'wal') {
            warn 'Note: Write-ahead mode not enabled';
        }
        
        return $self;
    }

    # sub _pick {
    #     # Similar to the hash slice, » $hash->%{@elements} « but only picks defined entries
    #     my ($hash, @elements) = @_;
    #     return map { exists $hash->{$_} ? ( $_, $hash->{$_} ) : () } @elements;
    # }

};

push @{app->commands->namespaces}, 'main::Command';

plugin 'Config';
plugin 'Minion' => { SQLite => 'sqlite:'.app->config->{dbname} };

helper db => sub {
    my ($self) = @_;
    state $db = Smoker::Database->new(database => $self->config->{dbname}, rebuild => ($self->app->mode eq 'rebuild'))->sql->db;
};

################

get '/modules' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT COUNT(*) AS count FROM modules')->hashes->first; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Database not configured or not populated'});
    }
};

get '/module/:modname' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT * FROM modules WHERE name=?', $self->stash('modname'))->hashes->first; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Module not found'});
    }
};

get '/tests/:modname' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT * FROM tests WHERE module_id=(SELECT id FROM modules WHERE name=?)',
                                         $self->stash('modname'))->hashes; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'No tests have been run, or Module not found'});
    }
};

get '/update' => sub {
    my ($self) = @_;
    my $id = $self->app->minion->enqueue('update', {priority => 0});
    $self->render(json => {job => {task => 'update', id => $id}});
};

get '/update/*uri' => sub {
    my ($self) = @_;
    my $id = $self->app->minion->enqueue('update' => [$self->stash('uri')], {priority => 0});
    $self->render(json => {job => {task => 'update', id => $id}});
};

get '/apply' => sub {
    my ($self) = @_;
    my $id = $self->app->minion->enqueue('apply', {priority => 0});
    $self->render(json => {job => {task => 'apply', id => $id}});
};

get '/job/:id' => sub {
    my ($self) = @_;
    my $job = $self->app->minion->job($self->stash('id'));
    $self->render(json => $job->info);
};

del '/job/:id' => sub {
    my ($self) = @_;
    my $deleted = $self->app->minion->job($self->stash('id'))->remove;
    $self->render(json => {success => $deleted});
};

get '/jobs/stats' => sub {
    my ($self) = @_;
    my $stats = $self->app->minion->stats;
    $self->render(json => $stats);
};

app->minion->add_task( update => sub { my ($job, @args) = @_;
                                       update( $job->app, @args);
                                       # probably call $job->finished($message) or $job->fail($message)
                                   } );

app->minion->add_task( apply => sub { my ($job, @args) = @_;
                                      apply( $job->app, @args);
                                      # probably call $job->finished($message) or $job->fail($message)
                                   } );

app->start;

__DATA__

@@sqlite_migrations

-- TABLE: Module
--  ModuleNum		0001				// Unique record number 
--  Author		BLACKJ				// module author
--  OptionalDir						// sometimes there is an extra dir in module path name
--  ModuleName		Acme-BLACKJ-Utils		// module name

-- TABLE: TestStatus
--  ModuleNum		0001				// FOREIGN KEY(Module) References Module(ModuleNum)
--  Error			Module not found|Disk Error...	// Misc. errors
--  BuildLog		Complete|Incomplete|Absent|Null|Pending	// created by cpanm --test-only 

--  BuildLogPath		smoke/.cpanm/perl-5.24.0/work/1234567890.12345/build.log 
--  BuildLogResult	Pass|Fail|Other
--  Revision		0.01				// module revision number
--  DisabledBy		ANDK|None			// ANDK = Testing disabled by this CPAN ID 
--							// [ANDK, BLUEWIND, current tester ID, etc.]
--							// None = Testing is enabled
--  PerlBuild		5.20.3-thread-debug		// module tested under this Perl build revision
--  TestDate		1496440070			// epoch date and time of test
--  TestDuration		83				// in seconds
--  CpanmReport		Complete|Incomplete|Absent	// created by cpanm-remporter
--  CpanmReportPath	smoke/.cpanmreporter/offline/sync/pass.Acme-BLACKJ-Utils_0.01.x86_64-linux-gnu-thread-multi.3.13.0-79-generic.[epoch].rpt]
--  CpanmReportSent	Yes|No|Unknown
--  ScriptName		Smoker.pl			// Perl script carrying out test
--  ScriptRevision	0.30				// test script revision
--  ScriptDate		1496300070			// epoch time of test script revision
--
-- -- -- --

-- 1 down

DROP TABLE IF EXISTS modules;
DROP INDEX IF EXISTS module_idx;
DROP TABLE IF EXISTS module_flags;
DROP INDEX IF EXISTS module_flags_idx;
DROP TABLE IF EXISTS tests;

-- 1 up

CREATE TABLE modules (
                      id INTEGER PRIMARY KEY,
                      name TEXT,
                      version TEXT,
                      released TIMESTAMP,  -- version timestamp
                      author TEXT,
                      relative_url TEXT,
                      disabled_by TEXT,
                      added TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    );

CREATE UNIQUE INDEX module_idx ON modules (name, version);

-- For storing the complex regexps that will be applied to module names,
-- thereby determining which modules are enabled and disabled.

CREATE TABLE module_flags (
                           id INTEGER PRIMARY KEY,
                           priority INTEGER, -- lower values take higher precedence
                           disable  INTEGER, -- enable (0) or disable (1) the modules in the regex
                           origin TEXT,  -- URL or filename
                           regex  TEXT,  -- Regular expression to match module names against
                           author TEXT,  -- PAUSE identifier
                           added TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                          );

CREATE UNIQUE INDEX module_flags_idx ON module_flags (origin);

CREATE TABLE environments (
                           id INTEGER PRIMARY KEY,
                           host TEXT,         -- Hostname (preferably full name; 'localhost' is less helpful)
                           -- These (platform, perl, osname, osvers) match fields in Testers Metabase
                           -- See https://github.com/barbie/cpan-testers-data-generator/
                           platform   TEXT,   
                           perl       TEXT,   -- Perl version
                           osname     TEXT,   --
                           osvers     TEXT,   --
                           added TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                           );

CREATE TABLE tests (
                    id INTEGER PRIMARY KEY,
                    module_id INTEGER,        -- UUT [unit under test]
                    version TEXT,             -- Version number as tested
                    error TEXT,               -- Last or most-severe error encountered
                    environment_id INTEGER,   -- replaces perl_build
                    test_started TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- when testing began (was enqueued)
                    test_finished TIMESTAMP,  -- replaces test_duration
                    build_log TEXT,           -- the complete build log
                    build_log_result TEXT,    -- parsed from the build log
                    cpanm_report TEXT,        -- as submitted
                    cpanm_report_sent TIMESTAMP,
                    -- script_name TEXT,
                    -- script_revision TEXT,    -- from CPAN
                    -- script_date TIMESTAMP,   -- from CPAN
                    FOREIGN KEY(module_id) REFERENCES modules(id),
                    FOREIGN KEY(environment_id) REFERENCES environments(id)
);
