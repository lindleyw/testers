#!/usr/bin/env perl

use Mojolicious::Lite;

use Mojo::Util qw(getopt);
use Mojo::URL;
use Mojo::File;
use Mojo::UserAgent;
use Mojo::DOM;
use List::Util qw(pairs);
use v5.22;
use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/lib/";

use CPAN::Wrapper;
use Tester::Smoker;

################################################################

# Can be called as, e.g.,
#   $ perl smoketest update ~/Documents/02packages.details.txt -m rebuild
# to rebuild and reload database from a local file, or:
#   $ perl smoketest update
# to update from the default CPAN location (remote URL)

# ./smoketest module --author PREACTION --count 5 --start_date=2012-07-01 --end_date=2012-12-30 -v -f

################################################################

# Find CPAN in the list of modules (it's currently under ANDK's directory)
# Get the current revision's list of disabled modules and use that to refresh the disabled list

# When relative_url is 'A/AN/ANDK/CPAN-2.16.tar.gz' name is CPAN, version is 2.16 --
# Fetch https://st.aticpan.org/source/ANDK/CPAN-2.16/distroprefs/01.DISABLED.yml

sub _pick {
     # Similar to the hash slice, » $hash->%{@elements} «
     # but only picks defined entries.
     my ($hash, @elements) = @_;
     return map { exists $hash->{$_} ? ( $_, $hash->{$_} ) : () } @elements;
}

sub _add_test {
    # Run a test on a given module, with a given module version,
    # on a given version of Perl
    my ($self, $mod_info) = @_;
    
    my $module_id = $mod_info->{module_id} // eval {
         # Because of the index `module_idx`, choosing the most-recent
         # module by name will always give us the latest version
         $self->app->db->select( -from => 'modules',
                                 -columns => ['id'],
                                 -where => { _pick ( $mod_info,
                                                     qw(name version) ) },
                                 -order_by => ['-added'],
                                 -limit => 1 )->hash->{id};
    };
    $self->smoker->minion->enqueue('test', { module_id => $module_id,
                                          env_id => $mod_info->{environment_id}
                                        });
}

sub _find_recent {
    my ($self, $mod_info, $limit) = @_;

    # example of passing more complex queries to _find_recent:
    #   _find_recent($self,{author =>'ANDK', name => {'LIKE', 'CPAN%'}})
    #   _find_recent($self,{added => {'>',\["datetime('now', ?)", '-21 day']}})

    my $modules =
         $self->app->db->select( -from => 'modules',
                                 # grouping by name after selecting max(added)
                                 # guarantees we get the most-recently-added version
                                 # for each module name
                                 -columns => ['id', 'name', 'max(added) as added'],
                                 -where => { _pick ( $mod_info,
                                                     qw(name version author added) ),
                                             disabled_by => undef, # not disabled
                                           },
                                 -group_by => ['name'],
                                 -order_by => ['-added'],  # most-recent first
                                 (defined $limit) ? (-limit => $limit) : (),
                               );
    return $modules->hashes;      # as a Mojo::Collection
}

sub _find_recent_days {
    my ($self, $day_count, $limit) = @_;
    return _find_recent($self,{added => {'>',\["datetime('now', ?)", -$day_count.' days']}}, $limit)
}

# TODO: api for selecting the number of modules added on a given date
# sqlite> select date(added), count(added) from modules group by date(added);

################################################################
################################################################
################################################################

package main::Command::list {
    use Mojo::Base 'Mojolicious::Command';
    use Minion::Backend;

    has 'description' => '';

    sub module_info {
        my ($self, $id) = @_;
        return eval {
            # Because of the index `module_idx`, choosing the most-recent
            # module by name will always give us the latest version
            $self->app->db->select( -from => 'modules',
                                    -where => { id => $id },
                                    -limit => 1 )->hashes->first;
        };
    }

    sub run {
        my ($self, @args) = @_;

        ; $DB::single = 1;

        my $jobs = $self->app->smoker->minion->backend->list_jobs(0, 50,  # offset, limit
                                                          {state => $args[0] // 'inactive',    # 'finished' or 'failed' are useful
                                                           task => 'test',
                                                          }
                                                         );
        print Mojo::Util::tablify [ [qw/Job Status Module Version Author/],
                                    map {
                                        if ( $_->{args}[0] eq 'module_id' ) {
                                            my $module_id = $_->{args}[1];
                                            if (!defined $module_id) {
                                                ()
                                            } else {
                                                [ $_->{id}, $_->{state},
                                                  $self->module_info($module_id)->@{qw/name version author/}]
                                            }
                                        } else {
                                            ()
                                        }
                                    }
                                    @{$jobs} ];
        return;
    }
};

package main::Command::reload {
    # formerly 'update' command, this reloads the entire CPAN list.
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->update(@args);
    }
};

################################################################

package main::Command::update_perl_versions {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->update_perl_versions(@args);
    }
};

package main::Command::update_module {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->update_module(@args);
    }
};

package main::Command::test_module {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @args) = @_;

        return 0;
    }
};

################################################################

package main::Command::regex {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->save_regex(@args);
    }

};

################################################################

package main::Command::update {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => "Retrieves and saves CPAN's list of recently-updated modules";

    sub run {
        my ($self, @args) = @_;

        my $updated_modules = $self->app->smoker->get_recent(@args);
        if ($self->app->smoker->check_regex(module_id => $updated_modules)) {
            print "modules updated OK";
        } else {
            print "could not update module list";
        }
    }
};

################################################################

package main::Command::module {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->test_metacpan(@args);
    }
};

################################################################

# Apply the enable/disable list(s)
#

package main::Command::apply {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->apply(@args);
    }
}

################################################################

# Create Test jobs for one module, or for all enabled modules
#

package main::Command::create {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => '';

    sub run {
        my ($self, @selected_modules) = @_;
    }
    
};

################################################################

# Force immediate in-this-thread execution of Minion jobs
# compare:   $ ./smoketest minion worker

package main::Command::do {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => 'Run any enqueued tests immediately, without using Minion workers';

    sub run {
        my ($self) = @_;
        $self->smoker->minion->perform_jobs();
    }
    
};

################################################################

package main::Command::rebuild {

    use Mojo::Base 'Mojolicious::Command';

    has 'description' => 'Discard the entire testing database and rebuild its structure.';

    sub run {
      my ($self) = @_;

      state $smoker = Tester::Smoker->new(database => $self->app->config->{dbname},
                                          config   => $self->app->config,
                                          log      => $self->app->log,
                                          rebuild  => 1,
                                         );
    }
};

################################################################
################################################################
################################################################

push @{app->commands->namespaces}, 'main::Command';

plugin 'Config';


# plugin 'Minion' => { SQLite => 'sqlite:'. app->config->{dbname} };

helper smoker => sub {
    my ($self) = @_;

    getopt
    'a|author=s'  => \my @authors,
    'module=s'    => \my @modules,
    'r|recent=i'  => \my $freshness,  # in days
    'rev|revision|version=s' => \my @versions,  # probably should change meaning of 'count'
    'perl=s'      => \my @perl_versions,  # probably should change meaning of 'count'
    'c|count=i'   => \my $count,
    'start|start_date=s', \my $start_date,
    'end|end_date=s', \my $end_date,
    'f|force'     => \my $force_test,
    'v|verbose'   => \my $verbose,
    ;

    state $smoker = Tester::Smoker->new(database => $self->config->{dbname},
                                        config   => $self->config,
                                        log      => $self->app->log,
                                        authors  => \@authors,
                                        modules  => \@modules,
                                        versions => \@versions,
                                        perl_versions => \@perl_versions,
                                        recent   => $freshness,
                                        start_date => $start_date,
                                        end_date => $end_date,
                                        count    => $count,
                                        force_test => $force_test,
                                        verbose  => $verbose,
                                        app => $self->app,
                                       );
    
};

helper sql => sub {
    my ($self) = @_;
    state $sql = $self->smoker->sql;
};

helper db => sub {
    my ($self) = @_;
    state $db = $self->sql->db;
};

plugin Minion => {SQLite => 'sqlite:'. app->config->{dbname}};
plugin 'Minion::Admin';

################

app->minion->add_task( test => sub { my ($job, @args) = @_;
                                     my ($result, @result_args) = $job->app->smoker->test($job, @args);
                                     if ($result eq 'success') {
                                         $job->finished(@result_args);
                                     } elsif ($result eq 'error') {
                                         $job->fail(@result_args);
                                     } else {
                                         # TODO: Better define why/when this can happen
                                         # $job->retry(@result_args);
                                     }
                                 } );

get '/modules' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT COUNT(*) AS count FROM modules')->hashes->first; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Database not configured or not populated'});
    }
};

get '/module/:modname' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT * FROM modules WHERE name=?', $self->stash('modname'))->hashes->first; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Module not found'});
    }
};

get '/tests/:modname' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT * FROM tests WHERE module_id=(SELECT id FROM modules WHERE name=?)',
                                         $self->stash('modname'))->hashes; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'No tests have been run, or Module not found'});
    }
};

# app->minion->add_task( update => sub { my ($job, @args) = @_;
#                                        my ($result, @result_args) = $job->app->smoker->update(@args);
#                                        if ($result eq 'success') {
#                                            $job->finished(@result_args);
#                                        } elsif ($result eq 'error') {
#                                            $job->fail(@result_args);
#                                        } else {
#                                            # TODO: Better define why/when this can happen
#                                            # $job->retry(@result_args);
#                                        }
#                                    } );

app->minion->add_task ( update => sub { my ($job, @args) = @_;
                                                my $results = $job->app->smoker->get_recent(@args);
                                                if (defined $results) {
                                                    ; $DB::single = 1;
                                                    # TODO: possibly:
                                                    # $job->app->minion->enqueue('check_regex', ... ?
                                                    $job->finished();
                                                } else {
                                                    $job->fail('Could not download updates list')
                                                }
                                            }
                              );

get '/update' => sub {
    my ($self) = @_;
    ; $DB::single = 1;
    my $id = $self->minion->enqueue('update', {priority => 0});
    $self->render(json => {job => {task => 'update', id => $id}});
};

get '/update/*uri' => sub {
    my ($self) = @_;
    my $id = $self->minion->enqueue('update' => [$self->stash('uri')], {priority => 0});
    $self->render(json => {job => {task => 'update', id => $id}});
};

app->minion->add_task( apply => sub { my ($job, @args) = @_;
                                      apply( $job->app, @args);
                                      # probably call $job->finished($message) or $job->fail($message)
                                   } );

get '/apply' => sub {
    my ($self) = @_;
    my $id = $self->minion->enqueue('apply', {priority => 0});
    $self->render(json => {job => {task => 'apply', id => $id}});
};

get '/job/:id' => sub {
    my ($self) = @_;
    my $job = $self->minion->job($self->stash('id'));
    $self->render(json => $job->info);
};

del '/job/:id' => sub {
    my ($self) = @_;
    my $deleted = $self->minion->job($self->stash('id'))->remove;
    $self->render(json => {success => $deleted});
};

get '/jobs/stats' => sub {
    my ($self) = @_;
    my $stats = $self->minion->stats;
    $self->render(json => $stats);
};

app->start;

__DATA__
