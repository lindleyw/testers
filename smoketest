#!/usr/bin/env perl

use Mojolicious::Lite;

use Mojo::Util qw(getopt);
use Mojo::URL;
use Mojo::File;
use Mojo::UserAgent;
use Mojo::DOM;
use List::Util qw(pairs);
use Email::Address;
use v5.22;
use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/lib/";

use CPAN::Wrapper;
use Tester::Smoker;

################################################################

# Can be called as, e.g.,
#   $ perl smoketest update
# to update from the metaCPAN API.

# ./smoketest release --author PREACTION --count 5 \
#   --start_date=2012-07-01 --end_date=2012-12-30

################################################################

package main::Command::list {
    use Mojo::Base 'Mojolicious::Command';
    use Minion::Backend;

    has 'description' => 'List currently-enqueued tests to be run';

    sub run {
        my ($self, @args) = @_;

        my $job_state = $args[0] // 'inactive';    # 'finished' or 'failed' are useful
        my $jobs = $self->app->minion->backend->list_jobs(0, 50,  # offset, limit
                                                          {state => $job_state,
                                                           task => 'test',
                                                          }
                                                         );
        if ($job_state eq 'finished') {
            print Mojo::Util::tablify [ [qw/Job Perl Result/],
                                        map {
                                            [ $_->{id}, $_->{notes}->{perl_version},
                                              $_->{result}
                                            ]
                                        }
                                        @{$jobs->{jobs}} ];
        } else {
            print Mojo::Util::tablify [ [qw/Job Status Distribution Version Author/],
                                        map {
                                            my $release_id = eval{$_->{args}->[0]->{'release_id'}};
                                            if (defined $release_id) {
                                                my $info = $self->app->smoker->get_release_info({id => $release_id}) if defined $release_id;
                                                if (!defined $info) {
                                                    ()
                                                } else {
                                                    [ $_->{id}, $_->{state},
                                                      $info->first->@{qw/name version author/}
                                                    ]
                                                }
                                            } else {
                                                ()
                                            }
                                        }
                                        @{$jobs->{jobs}} ];
        }
        return;
    }
};

################################################################

package main::Command::update_perl_versions {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => 'Updates the list of Perl versions installed via Perlbrew';
    has usage => sub { shift->extract_usage };

=head1 SYNOPSIS

Usage: APPLICATION update_perl_versions [options]

Options:
   -v ver something
=cut

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->update_perl_versions(@args);
    }
};

################################################################

package main::Command::regex {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => 'Retrieves and updates, from metacpan, the cached copy of the regex for disabled modules';
    has usage => sub { shift->extract_usage };

=head1 SYNOPSIS

Usage: APPLICATION regex [options]

Options:
   -s something
=cut

    sub run {
        my ($self, @args) = @_;

        return $self->app->smoker->fetch_and_save_regex(@args);
    }

};

################################################################

package main::Command::reload {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => 'Reloads the entire list of modules from MetaCPAN';

    sub run {
        my ($self, @args) = @_;
        my $updated_releases = $self->app->smoker->get_all(@args);
        if ($self->app->smoker->check_regex(release_id => $updated_releases)) {
            $self->app->log->info("modules updated OK");
        } else {
            $self->app->log->error("could not update module list");
        }
    }
};

################################################################

package main::Command::update {
    use Mojo::Base 'Mojolicious::Command';
    use Mojo::Util qw(getopt);

    has 'description' => 'Retrieves distribution info from MetaCPAN and enqueues tests';

    sub run {
        my ($self, @args) = @_;
        getopt \@args, [qw(auto_abbrev)],
          'v|verbose' => \my $verbose,   # Note abbrev, versus -version below
          'count=i' => \my $count,
          'force'   => \my $force_test,
          'notest'  => \my $skip_tests,
          'distribution|distro=s' => \my @dists,
          'version=s' => \my @versions,  # one 'Release' is a 'Distribution-Version' combination,
          'release=s' => \my @releases,  # so generally either specify release or distro(+version).
          'author=s' => \my @authors,
          'perl_version=s' => \my @perl_versions,
          'start_date=s' => \my $start_date,
          'end_date=s'   => \my $end_date;

        # Split/join to also permit comma-delimited
        my $releases =
          $self->app->smoker->get_metacpan( { count => $count,
                                              main_module => [split ',', join ',', @dists],
                                              name => [split ',', join ',', @releases],
                                              version => [split ',', join ',', @versions],
                                              author => [split ',', join ',', @authors],
                                              start_date => $start_date,
                                              end_date => $end_date,
                                            } );

        # Ensure updated list of installed Perl versions
        $self->app->smoker->update_perl_versions(@args);

        my @perl_test_versions;
        foreach my $v (split ',', join ',', @perl_versions) {
            # Look for Perlbrew name first, then Perl's self-reported version
            my $vv = $self->app->smoker->get_environment({perlbrew => $v}) //
                $self->app->smoker->get_environment({perl => $v});
            if (defined $vv) {
                push @perl_test_versions, $vv
            } else {
                die "Perl version ($v) not found";
            }
        }
        # Default to current environment
        if (!scalar @perl_test_versions) {
          @perl_test_versions = ($self->app->smoker->get_environment({id => $self->app->smoker->my_environment()}));
        }
        # Enqueue tests for each of those releases.
        if (defined $releases && !$skip_tests) {
          $self->app->log->info('Enqueueing ' . $releases->size . ' releases') if $verbose;
          $releases->each(sub {
                            my $id = $_->{id};
                            # TODO: Move below into separate routine
                            # TODO: Probably move enqueue() calls into Smoker
                            foreach my $v (@perl_test_versions) {
                                # XXX: ?+0 to work around DBD::SQLite issue; c.f.
                                # https://metacpan.org/pod/DBD::SQLite#Add-zero-to-make-it-a-number
                                my $skip;
                                if (!defined $force_test) {
                                    $skip = eval{$self->app->sql->db->query(q{SELECT id FROM minion_jobs WHERE }.
                                                                            q{(task='test') AND }.
                                                                            q{json_extract(args,'$[0].release_id')=?+0 }.
                                                                            q{AND json_extract(args,'$[0].environment')=?+0},
                                                                            $id, $v->{id})->hashes->first->{id}};
                                    $skip //= eval{$self->app->sql->db->select(-from => 'tests',
                                                                               -where => {release_id => $id,
                                                                                          environment_id => $v})
                                                   ->hashes->first->{id}};
                                    $skip = " (skipping, already tested)" if defined $skip;
                                }
                                $self->app->log->info('  ... ' . $_->{name} .
                                                      ' (Perl ' . ($v->{perlbrew} // $v->{perl}) . ')' .
                                                      ($skip//''))
                                  if $verbose;
                                if (!defined $skip) {
                                    $self->app->minion->enqueue(test => [{release_id => $id, environment => $v->{id}}],
                                                                {notes => {module_info => $_,
                                                                           perl_version => ($v->{perlbrew} // $v->{perl})
                                                                          }});
                                }
                            }
                        });
      }

    }
};

################################################################

# Force immediate in-this-thread execution of Minion jobs
# compare:   $ ./smoketest minion worker

package main::Command::do {
    use Mojo::Base 'Mojolicious::Command';

    has 'description' => 'Run any enqueued tests immediately, without using Minion workers';

    sub run {
        my ($self) = @_;
        $self->app->minion->perform_jobs();
    }
    
};

################################################################

package main::Command::rebuild {

    use Mojo::Base 'Mojolicious::Command';

    has 'description' => 'Discard the entire testing database and rebuild its structure.';

    sub run {
      my ($self) = @_;

      state $smoker = Tester::Smoker->new(database => $self->app->config->{dbname},
                                          config   => $self->app->config,
                                          log      => $self->app->log,
                                          rebuild  => 1,
                                         );
    }
};

################################################################
################################################################
################################################################

push @{app->commands->namespaces}, 'main::Command';

plugin 'Config';

helper smoker => sub {
    my ($self) = @_;

    state $smoker = Tester::Smoker->new(database => $self->config->{dbname},
                                        config   => $self->config,
                                        log      => $self->app->log,
                                        # authors  => \@authors,
                                        # modules  => \@modules,
                                        # versions => \@versions,
                                        # perl_versions => \@perl_versions,
                                        # recent   => $freshness,
                                        # start_date => $start_date,
                                        # end_date => $end_date,
                                        # count    => $count,
                                        # force_test => $force_test,
                                        # verbose  => $verbose,
                                        app => $self->app,
                                       );
    
};

helper sql => sub {
    my ($self) = @_;
    state $sql = $self->smoker->sql;
};

helper db => sub {
    my ($self) = @_;
    state $db = $self->sql->db;
};

plugin Minion => {SQLite => 'sqlite:'. app->config->{dbname}};
plugin 'Minion::Admin';

################

app->minion->add_task( test => sub { my ($job, @args) = @_;
                                     my ($result, @result_args) = $job->app->smoker->test($job, @args);
                                     if ($result eq 'success') {
                                         $job->finished(@result_args);
                                     } elsif ($result eq 'error') {
                                         $job->fail(@result_args);
                                     } else {
                                         # TODO: Better define why/when this can happen
                                         # $job->retry(@result_args);
                                     }
                                 } );

get '/releases' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT COUNT(*) AS count FROM releases')->hashes->first; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Database not configured or not populated'});
    }
};

get '/release/#release' => sub {   # octothorpe placeholder because releases contain '.'
    my $self = shift;

    # /release/Mojolicious-7.58
    my $result = eval { $self->db->query('SELECT * FROM releases WHERE name=?',
                                         $self->stash('release'))->hashes->first; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Release not found'});
    }
};

get '/distribution/:dist' => sub {
    my $self = shift;

    # /distribution/Mojolicious
    my $result = eval { $self->db->query('SELECT * FROM releases WHERE distribution=?',
                                         $self->stash('dist'))->hashes; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Distribution not found'});
    }
};

get '/author/:auth' => sub {
    my $self = shift;

    # /distribution/Mojolicious
    my $result = eval { $self->db->query('SELECT * FROM releases WHERE author=?',
                                         $self->stash('auth'))->hashes; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Distribution not found'});
    }
};

get '/report/:id' => sub {
    my $self = shift;

    my $test = $self->smoker->report_for($self->stash('id'));
    unless (defined $test && defined ($test = $test->first)) {
        $self->render(json => {error => 'Report not found'});
        return undef;
    }
    my ($release_name, $release_version) = $test->{name} =~ m{^(.+)-([^-]+)};
    my $email_from = (Email::Address->parse($self->smoker->tester->config->email_from))[0];
    my ($submitter_email, $submitter_name) = (defined $email_from) ?
         ( $email_from->address, $email_from->name ) : ('NOT CONFIGURED!','NOT CONFIGURED!');
    my $result = { environment => { language => { name => 'Perl 5',
                                                  version => $test->{perl},
                                                  archname => $test->{archname},
                                                },
                                    system => { osname => $test->{osname},
                                                osversion => $test->{osvers},
                                              },
                                  },
                   reporter => { email => $submitter_email,
                                 name =>  $submitter_name,
                               },
                   distribution => { name => $release_name,
                                     version => $test->{version},  # should be same as $release_version
                                   },
                   result => { grade => $test->{grade},
                               output => $test->{report},
                               # XXX: Question: Do we want $test->{build_log} ?
                             },
                   };
    $self->render(json => $result);
};

get '/tests/#release' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT * FROM tests WHERE release_id in (SELECT id FROM releases WHERE name=?)',
                                         $self->stash('release'))->hashes; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'No tests have been run, or Distribution not found'});
    }
};

get '/tests/distribution/:distribution' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT * FROM tests WHERE release_id in (SELECT id FROM releases WHERE distribution=?)',
                                         $self->stash('distribution'))->hashes; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'No tests have been run, or Distribution not found'});
    }
};

get '/test/:id' => sub {
    my $self = shift;

    my $result = eval { $self->db->query('SELECT * FROM tests WHERE id=?',
                                         $self->stash('id'))->hashes; };
    if (defined $result) {
        $self->render(json => $result);
    } else {
        $self->render(json => {error => 'Test not found'});
    }
};

app->minion->add_task ( update => sub { my ($job, @args) = @_;
                                                my $results = $job->app->smoker->get_recent(@args);
                                                if (defined $results) {
                                                    # TODO: possibly:
                                                    # $job->app->minion->enqueue('check_regex', ... ?
                                                    $job->finished();
                                                } else {
                                                    $job->fail('Could not download updates list')
                                                }
                                            }
                              );

get '/update' => sub {
    my ($self) = @_;
    my $id = $self->minion->enqueue('update', {priority => 0});
    $self->render(json => {job => {task => 'update', id => $id}});
};

get '/update/*uri' => sub {
    my ($self) = @_;
    my $id = $self->minion->enqueue('update' => [$self->stash('uri')], {priority => 0});
    $self->render(json => {job => {task => 'update', id => $id}});
};

get '/job/:id' => sub {
    my ($self) = @_;
    my $job = $self->minion->job($self->stash('id'));
    $self->render(json => $job->info);
};

del '/job/:id' => sub {
    my ($self) = @_;
    my $deleted = $self->minion->job($self->stash('id'))->remove;
    $self->render(json => {success => $deleted});
};

get '/jobs/stats' => sub {
    my ($self) = @_;
    my $stats = $self->minion->stats;
    $self->render(json => $stats);
};

app->start;

__DATA__
