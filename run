LICENSE:5: 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
LICENSE:14:software--to make sure the software is free for all its users.  This
LICENSE:138:    a) Accompany it with the complete corresponding machine-readable
LICENSE:145:    machine-readable copy of the corresponding source code, to be
LICENSE:205:license would not permit royalty-free redistribution of the Program by
LICENSE:308:    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
LICENSE:323:mouse-clicks or menu items--whatever suits your program.
lib/CPAN/Wrapper.pm:6:    use Mojo::Base '-base';
lib/CPAN/Wrapper.pm:17:      App::cpanminus::reporter->new->build_dir;
lib/CPAN/Wrapper.pm:37:    #    'archname' => 'x86_64-linux'
lib/CPAN/Wrapper.pm:38:    #    'dist' => 'Acme-CPAN-Testers-FAIL-0.02'
lib/CPAN/Wrapper.pm:40:    #    'osvers' => '4.4.0-63-generic'
lib/CPAN/Wrapper.pm:47:    # # Consider this code from App::cpanminus::reporter --
lib/CPAN/Wrapper.pm:48:    #   my $cpanm_version = $self->{_cpanminus_version} || 'unknown cpanm version';
lib/CPAN/Wrapper.pm:49:    #   my $meta = $self->get_meta_for( $dist );
lib/CPAN/Wrapper.pm:50:    #   my $client = CPAN::Testers::Common::Client->new(
lib/CPAN/Wrapper.pm:51:    #                                                   author      => $self->author,
lib/CPAN/Wrapper.pm:56:    #                                                   prereqs     => ($meta && ref $meta) ? $meta->{prereqs} : undef,
lib/CPAN/Wrapper.pm:59:    #   if (!$self->skip_history && $client->is_duplicate) {
lib/CPAN/Wrapper.pm:61:    #       if $self->verbose;
lib/CPAN/Wrapper.pm:64:    #     print "sending: ($resource, $author, $dist, $result)\n" unless $self->quiet;
lib/CPAN/Wrapper.pm:67:    #   my $reporter = Test::Reporter->new(
lib/CPAN/Wrapper.pm:68:    #                                      transport      => $self->config->transport_name,
lib/CPAN/Wrapper.pm:69:    #                                      transport_args => $self->config->transport_args,
lib/CPAN/Wrapper.pm:70:    #                                      grade          => $client->grade,
lib/CPAN/Wrapper.pm:72:    #                                      distfile       => $self->distfile,
lib/CPAN/Wrapper.pm:73:    #                                      from           => $self->config->email_from,
lib/CPAN/Wrapper.pm:74:    #                                      comments       => $client->email,
lib/CPAN/Wrapper.pm:75:    #                                      via            => $client->via,
lib/CPAN/Wrapper.pm:77:      # if ($self->dry_run) {
lib/CPAN/Wrapper.pm:78:      #   print "not sending (drun run)\n" unless $self->quiet;
lib/CPAN/Wrapper.pm:83:      #   $reporter->send() || die $reporter->errstr();
lib/CPAN/Wrapper.pm:86:      #     print "Error while sending this report, continuing with the next one...\n" unless $self->quiet;
lib/CPAN/Wrapper.pm:87:      #     print "DEBUG: @_" if $self->verbose;
lib/CPAN/Wrapper.pm:89:      #     $client->record_history unless $self->skip_history;
lib/CPAN/Wrapper.pm:108:    #     # NOTE: CPAN::Shell->test(...) calls its function rematein(...) which
lib/CPAN/Wrapper.pm:111:    #     my ($stdout, $stderr, @result) = eval { capture { CPAN::Shell->test ( @args ) } };
lib/CPAN/Wrapper.pm:119:        my $ua = Mojo::UserAgent->new();
lib/CPAN/Wrapper.pm:120:        my $source_url = Mojo::URL->new($self->config->{metacpan}->{$type // 'module'}); # API endpoint
lib/CPAN/Wrapper.pm:121:        push @{$source_url->path->parts}, $module_name;
lib/CPAN/Wrapper.pm:122:        my $result = eval { $ua->max_redirects(5)->get($source_url); };
lib/CPAN/Wrapper.pm:123:        if (defined $result && $result->res->{code} == 200) {
lib/CPAN/Wrapper.pm:124:            my $module_fields = $result->res->json;
lib/CPAN/Wrapper.pm:136:    # When download_url is 'A/AN/ANDK/CPAN-2.16.tar.gz' name is CPAN,
lib/CPAN/Wrapper.pm:137:    # version is 2.16 -- Fetch
lib/CPAN/Wrapper.pm:138:    # https://st.aticpan.org/source/ANDK/CPAN-2.16/distroprefs/01.DISABLED.yml
lib/CPAN/Wrapper.pm:142:      my $source_url = Mojo::URL->new($self->config->{source});
lib/CPAN/Wrapper.pm:143:      return undef unless defined $self->current_cpan;
lib/CPAN/Wrapper.pm:144:      push @{$source_url->path->parts}, ( $self->current_cpan->{author},
lib/CPAN/Wrapper.pm:145:                                          'CPAN-' . $self->current_cpan->{version},
lib/CPAN/Wrapper.pm:147:                                          $self->config->{disable} //
lib/CPAN/Wrapper.pm:150:      $source_url->path->trailing_slash(0);
lib/CPAN/Wrapper.pm:159:        my $source_url = Mojo::URL->new($self->config->{testers} );
lib/CPAN/Wrapper.pm:160:        push @{$source_url->path->parts},
lib/CPAN/Wrapper.pm:162:          $self->config->{$which_list} // $default_list_url->{$which_list};
lib/CPAN/Wrapper.pm:168:    # NOTE: This simple array serves as a substitute for the much-heavier:
lib/CPAN/Wrapper.pm:176:        $module_tgzs->each( sub {
lib/CPAN/Wrapper.pm:179:                                @{$module_info}{qw(author name version)} = ( $module_node->attr('href') =~ # from the URL,
lib/CPAN/Wrapper.pm:180:                                                                             m{(\w+)/([^/]+?)-?v?([0-9a-z.]+)?\.tar\.gz}
lib/CPAN/Wrapper.pm:182:                                $module_info->{name} =~ s/-/::/g;
lib/CPAN/Wrapper.pm:185:                                my $module_info_text = $module_node->next_node->content =~ s/\A\s+//r =~ s/\s+\z//r;
lib/CPAN/Wrapper.pm:186:                                ($module_info->{size}, my $m_day, my $m_mon, my $m_year) = split(/\s+/, $module_info_text, 4);
lib/CPAN/Wrapper.pm:188:                                $module_info->{size} =~ s/^([0-9.])+([kM])/$1*({k=>1024,M=>1024*1024}->{$2})/e;
lib/CPAN/Wrapper.pm:192:                                $module_info->{released} = sprintf('%4d-%02d-%02d', $m_year, $months{lc($m_mon)}, $m_day);
lib/CPAN/Wrapper.pm:195:        return Mojo::Collection->new(@modules);
lib/CPAN/Wrapper.pm:200:    ### lighter-weight alternative to Parse::CPAN::Packages (which
lib/CPAN/Wrapper.pm:208:        $vals->{author} = ($vals->{download_url} =~ m{^./../(\w+)/})[0];
lib/CPAN/Wrapper.pm:209:        $vals->{version} = undef if ($vals->{version} eq 'undef'); # Replace text 'undef'
lib/CPAN/Wrapper.pm:219:        my $module_tgzs = Mojo::Collection->new (
lib/CPAN/Wrapper.pm:241:      my $source_url = Mojo::URL->new($source // $self->config->{testers});
lib/CPAN/Wrapper.pm:242:      if ($source_url->protocol || $source_url->host) { # Looks like a remote file
lib/CPAN/Wrapper.pm:243:          unless (length($source_url->path) > 1) { # no path, or '/'
lib/CPAN/Wrapper.pm:244:              push @{$source_url->path->parts}, ( 'modules',
lib/CPAN/Wrapper.pm:245:                                                  $self->config->{all} //
lib/CPAN/Wrapper.pm:249:          my $ua = Mojo::UserAgent->new();
lib/CPAN/Wrapper.pm:250:          $module_list = eval { $ua->max_redirects(5)->get($source_url)->result; };
lib/CPAN/Wrapper.pm:252:              if ($module_list->is_success) {
lib/CPAN/Wrapper.pm:253:                  if ($source_url->path =~ /\.htm/) {
lib/CPAN/Wrapper.pm:254:                      $module_dom = $module_list->dom;
lib/CPAN/Wrapper.pm:256:                      $module_list = $module_list->body; # plaintext contents
lib/CPAN/Wrapper.pm:258:                  $self->log->info("Fetched remote module list.");
lib/CPAN/Wrapper.pm:260:                  $self->log->error("Can't download modules list: ".$module_list->message);
lib/CPAN/Wrapper.pm:264:              $self->log->error("Can't download modules list: ".$@);
lib/CPAN/Wrapper.pm:268:          $module_list = Mojo::File->new($source)->slurp;
lib/CPAN/Wrapper.pm:270:              $module_dom = Mojo::DOM->new($module_list) if ($module_list =~ /<html/i);
lib/CPAN/Wrapper.pm:272:              $self->log->error("No module list file");
lib/CPAN/Wrapper.pm:279:        $module_tgzs = _dom_extract($module_dom->find('a[href$=".tar.gz"]'));
lib/CPAN/Wrapper.pm:297:        # Returns empty list (which gets skipped in building list later) if no author, -or-
lib/CPAN/Wrapper.pm:300:        #           {'term' => {'author' => 'JBERGER'}}]}  # 'PREACTION,JBERGER' passed-in
lib/CPAN/Wrapper.pm:311:        # XXX: Probably eliminate the special-case of ref and move that logic into _versions() below
lib/CPAN/Wrapper.pm:332:    ### Are we parsing the returned value equivalently to get_modules() --?
lib/CPAN/Wrapper.pm:336:        # See also: https://github.com/metacpan/metacpan-api/blob/master/docs/API-docs.md
lib/CPAN/Wrapper.pm:338:        my $ua = Mojo::UserAgent->new();
lib/CPAN/Wrapper.pm:343:        $source_url = $self->config->{metacpan}->{release}; # API endpoint;
lib/CPAN/Wrapper.pm:346:        # 'name'  (e.g., 'Mojolicious-7.46') is the full release name+version.
lib/CPAN/Wrapper.pm:348:        my @want_versions = _item_list(['version', {term => {'status' => 'latest'}}], $args->{version});
lib/CPAN/Wrapper.pm:349:        my @want_count = ( size => $args->{count} // 10);
lib/CPAN/Wrapper.pm:352:        if (defined $args->{name} && scalar @{$args->{name}}) {
lib/CPAN/Wrapper.pm:356:            # @want_count = (size => scalar @{$args->{name}});   # exactly that many
lib/CPAN/Wrapper.pm:357:        } elsif (defined $args->{main_module} && scalar @{$args->{main_module}}) {
lib/CPAN/Wrapper.pm:360:            if (scalar @{$args->{version}}) {  # Get specific version(s). Omit count.
lib/CPAN/Wrapper.pm:364:                @want_count = (size => $args->{count} // scalar @{$args->{main_module}});
lib/CPAN/Wrapper.pm:371:                    'filter' => {'and' => [_item_list('main_module', $args->{main_module}), # e.g., 'Mojolicious'
lib/CPAN/Wrapper.pm:372:                                           _item_list('name', $args->{name}),     # e.g., 'Mojolicious-7.46'
lib/CPAN/Wrapper.pm:373:                                           _item_list('author', $args->{author}),
lib/CPAN/Wrapper.pm:377:                                _date_range( $args->{start_date}, $args->{end_date} ) },
lib/CPAN/Wrapper.pm:380:        # NOTE: Above could request $module->{fields}->{provides}
lib/CPAN/Wrapper.pm:384:        my $modules = $ua->post($source_url => json => $req)->result;
lib/CPAN/Wrapper.pm:385:        my $module_list = defined ($modules) ? Mojo::JSON::decode_json($modules->body) : {};
lib/CPAN/Wrapper.pm:399:        #                     'date' => '2017-11-16T13:33:27',
lib/CPAN/Wrapper.pm:401:        #                     'download_url' => 'https://cpan.metacpan.org/authors/id/S/SR/SRI/Mojolicious-7.56.tar.gz',
lib/CPAN/Wrapper.pm:403:        #                     'name' => 'Mojolicious-7.56'
lib/CPAN/Wrapper.pm:408:        return map { $_->{fields} } @{$module_list->{hits}->{hits}};
lib/CPAN/Wrapper.pm:429:        my $source_url = $use_latest ? $self->disabled_regex_url : Mojo::URL->new($source);
lib/CPAN/Wrapper.pm:432:        if ($source_url->protocol || $source_url->host) { # looks like a URL
lib/CPAN/Wrapper.pm:434:                my $cpan = $self->current_cpan;
lib/CPAN/Wrapper.pm:436:                    $self->log->error("Can't find current CPAN for regex");
lib/CPAN/Wrapper.pm:439:                $source = $self->disabled_regex_url();
lib/CPAN/Wrapper.pm:441:                    $self->log->error("Can't load CPAN regex URL");
lib/CPAN/Wrapper.pm:444:                $source_url = Mojo::URL->new($source);
lib/CPAN/Wrapper.pm:445:                $reason = $cpan->{author} . '/CPAN-' . $cpan->{version};
lib/CPAN/Wrapper.pm:448:                if ($cpan->{version} ne version()) {
lib/CPAN/Wrapper.pm:449:                    $self->log->warn ("Our cpan=".version()." but remote is ". $cpan->{version});
lib/CPAN/Wrapper.pm:455:            $self->log->info("Reading Module regex from $source");
lib/CPAN/Wrapper.pm:456:            $disabled_list = Mojo::UserAgent->new()->max_redirects(5)->get($source_url)->result;
lib/CPAN/Wrapper.pm:457:            unless ($disabled_list->is_success) {
lib/CPAN/Wrapper.pm:458:                $self->log->warn("Can't download regex: ".$disabled_list->message);
lib/CPAN/Wrapper.pm:461:            $disabled_list = $disabled_list->body;
lib/CPAN/Wrapper.pm:465:            unless (-r $source) {
lib/CPAN/Wrapper.pm:466:                $self->log->error("Cannot read regex file: $source");
lib/CPAN/Wrapper.pm:469:            $disabled_list = Mojo::File->new($source)->slurp;
lib/CPAN/Wrapper.pm:471:                $self->log->error("Module list file ($source) is empty?");
lib/CPAN/Wrapper.pm:476:        # Decode and save as meta-information in the Modules list
lib/CPAN/Wrapper.pm:479:            $self->log->error("Cannot decode YAML: $@");
lib/CPAN/Wrapper.pm:484:                 disable => $matchfile->{disabled},
lib/CPAN/Wrapper.pm:485:                 regex => $matchfile->{match}{distribution}
lib/CPAN/TestersDB.pm:11:    use Mojo::Base '-base';
lib/CPAN/TestersDB.pm:29:        my ($release_name, $release_version) = $test->{name} =~ m{^(.+)-([^-]+)};
lib/CPAN/TestersDB.pm:30:        $self->log->info("report_json ($release_name)");
lib/CPAN/TestersDB.pm:32:                                                version => $test->{perl},
lib/CPAN/TestersDB.pm:33:                                                archname => $test->{archname},
lib/CPAN/TestersDB.pm:35:                                  system => { osname => $test->{osname},
lib/CPAN/TestersDB.pm:36:                                              osversion => $test->{osvers},
lib/CPAN/TestersDB.pm:39:                 reporter => $self->user_email,
lib/CPAN/TestersDB.pm:41:                                   version => $test->{version}, # should be same as $release_version
lib/CPAN/TestersDB.pm:43:                 result => { grade => $test->{grade},
lib/CPAN/TestersDB.pm:44:                             output => { uncategorized => $test->{report} },
lib/CPAN/TestersDB.pm:45:                             duration => ($test->{duration} // $test->{elapsed_time} // 0) +.5,
lib/CPAN/TestersDB.pm:46:                             # XXX: Question: Do we want $test->{build_log} ?
lib/CPAN/TestersDB.pm:50:                 user_agent => $self->config->{user_agent} // 'Smoketest/'.$::VERSION,
lib/CPAN/TestersDB.pm:57:        my $ua = Mojo::UserAgent->new();
lib/CPAN/TestersDB.pm:58:        my $source_url = Mojo::URL->new($self->config->{submit_url});
lib/CPAN/TestersDB.pm:60:        my $result = eval { $ua->max_redirects(5)->post($source_url,
lib/CPAN/TestersDB.pm:63:        $self->log->info("Submit report ($source_url): result code=" .  $result->res->{code})
lib/CPAN/TestersDB.pm:66:                                              code => $result->res->code,
lib/CPAN/TestersDB.pm:67:                                              body => $result->res->body,
lib/CPAN/TestersDB.pm:68:                                              message => $result->res->message };
lib/CPAN/TestersDB.pm:75:        my $ua = Mojo::UserAgent->new();
lib/CPAN/TestersDB.pm:76:        my $source_url = Mojo::URL->new($self->config->{metacpan}->{$type // 'module'}); # API endpoint
lib/CPAN/TestersDB.pm:77:        push @{$source_url->path->parts}, $module_name;
lib/Tester/Smoker.pm:6:    use Mojo::Base -base;
lib/Tester/Smoker.pm:19:        if (defined $self->database) {
lib/Tester/Smoker.pm:20:          my $db = Mojo::SQLite->new('sqlite:' . $self->database);
lib/Tester/Smoker.pm:21:          # $db->options( {sqlite_see_if_its_a_number => 1} );
lib/Tester/Smoker.pm:22:          $db->abstract(SQL::Abstract::More->new());
lib/Tester/Smoker.pm:37:        state $tm = TestModule->new(log => $self->log);
lib/Tester/Smoker.pm:43:        state $email_from = (Email::Address->parse($self->tester->config->email_from))[0];
lib/Tester/Smoker.pm:45:            {email => $email_from->address, name => $email_from->name} :
lib/Tester/Smoker.pm:53:        my $cpan = CPAN::Wrapper->new(config => $self->config->{cpan},
lib/Tester/Smoker.pm:54:                                      log => $self->log,
lib/Tester/Smoker.pm:61:        my $cpan_module = $self->get_release_info({name => 'CPAN'})->first;
lib/Tester/Smoker.pm:62:        if ((!defined $cpan_module) || ($cpan_module->{version} ne $cpan->version)) {
lib/Tester/Smoker.pm:63:            # NOTE: We cannot use $self->update_module() here, because
lib/Tester/Smoker.pm:64:            # that depends on the $self->cpan object, which we haven't
lib/Tester/Smoker.pm:66:            $cpan_module = $cpan->get_module_info('CPAN','release');   # Fetch latest version from metacpan
lib/Tester/Smoker.pm:68:                $cpan_module->{_db_id} = $self->save_release_info($cpan_module);  # keep new id value
lib/Tester/Smoker.pm:69:                $self->_update_regex(1);
lib/Tester/Smoker.pm:72:        if (defined $cpan_module && ($cpan->version ne $cpan_module->{version})) {
lib/Tester/Smoker.pm:73:            ### NOTE: As of 2017-11-20, Perlbrew install cpan version
lib/Tester/Smoker.pm:79:            $self->log->warn ("Our cpan=". $cpan->version ." but remote is ". $cpan_module->{version});
lib/Tester/Smoker.pm:82:        $cpan->current_cpan({%{$cpan_module}{qw(version author)}}); # Completes the cpan object's attributes
lib/Tester/Smoker.pm:90:        my $cpan_tester = CPAN::TestersDB->new(config => $self->config->{db_api},
lib/Tester/Smoker.pm:91:                                               log => $self->log,
lib/Tester/Smoker.pm:92:                                               user_email => $self->user_email,
lib/Tester/Smoker.pm:99:        my $self = $class->SUPER::new(@_);
lib/Tester/Smoker.pm:101:        $self->sql->migrations->name('smoker_migrations')->
lib/Tester/Smoker.pm:104:        $self->sql->migrations->tap(sub { $self->rebuild and $_->migrate(0) })->migrate;
lib/Tester/Smoker.pm:105:        my $jmode = $self->sql->db->query('PRAGMA journal_mode=WAL;');
lib/Tester/Smoker.pm:106:        if ($jmode->arrays->[0]->[0] ne 'wal') {
lib/Tester/Smoker.pm:107:            warn 'Note: Write-ahead mode not enabled';
lib/Tester/Smoker.pm:109:        $self->sql->db->query('PRAGMA foreign_keys=1;');
lib/Tester/Smoker.pm:118:        # Returns the id of our native (non-Perlbrew) environment, adding it if required
lib/Tester/Smoker.pm:126:        my $env = eval { $self->sql->db->select(-from => 'environments',
lib/Tester/Smoker.pm:127:                                                -columns => ['id'],
lib/Tester/Smoker.pm:128:                                                -where => $my_config)->hashes; };
lib/Tester/Smoker.pm:129:        if (defined $env && $env->size) {
lib/Tester/Smoker.pm:130:            return $env->first->{id};
lib/Tester/Smoker.pm:132:            return eval { $self->sql->db->insert(-into => 'environments',
lib/Tester/Smoker.pm:133:                                                 -values => $my_config)->last_insert_id;
lib/Tester/Smoker.pm:145:            $self->my_environment();
lib/Tester/Smoker.pm:149:                    $self->sql->db->query('INSERT INTO environments(host, perlbrew) VALUES (?,?)',
lib/Tester/Smoker.pm:150:                                          hostname(), $v)->last_insert_id;
lib/Tester/Smoker.pm:154:                    $id = eval{$self->sql->db->select(-from => 'environments',
lib/Tester/Smoker.pm:155:                                                      -columns => 'id',
lib/Tester/Smoker.pm:156:                                                      -where => { host => hostname(),
lib/Tester/Smoker.pm:159:                                                     )->hashes->first->{id}};
lib/Tester/Smoker.pm:162:                    $self->log->error("Cannot add perl version $v");
lib/Tester/Smoker.pm:165:                # NOTE: Uses currently-running kernel version from
lib/Tester/Smoker.pm:171:                my $version_specific = `perlbrew exec --with $v perl -MConfig -MSys::Hostname -e 'use POSIX; print join("\n", %Config{qw(osname version archname)}, 'osvers', (POSIX::uname())[2])'`;
lib/Tester/Smoker.pm:172:                # returns, e.g.: (perl-5.24.1)\n===...===\n and
lib/Tester/Smoker.pm:173:                # results in form of: " * perl-5.24.0-alias (5.22)"
lib/Tester/Smoker.pm:177:                        $self->sql->db->update( -table => 'environments',
lib/Tester/Smoker.pm:178:                                                -set => { $version_info->%{qw(osname osvers archname)}, # hash slice
lib/Tester/Smoker.pm:179:                                                          perl => $version_info->{version},
lib/Tester/Smoker.pm:181:                                                -where => { id => $id }
lib/Tester/Smoker.pm:185:                    # Attempting to `perlbrew exec --with` an
lib/Tester/Smoker.pm:188:                    eval { $self->sql->db->query('DELETE FROM environments WHERE id=?',$id); };
lib/Tester/Smoker.pm:202:        my $regex = $self->cpan->load_regex($source);
lib/Tester/Smoker.pm:204:          my $saved = $self->sql->db->query('INSERT OR REPLACE INTO module_flags (priority, origin, author, disable, regex) '.
lib/Tester/Smoker.pm:218:            $self->sql->db->select(-from => 'module_flags',
lib/Tester/Smoker.pm:219:                                   -order_by => [{-desc => 'priority'}, {-desc => 'added'}],
lib/Tester/Smoker.pm:220:                                  )->hashes;
lib/Tester/Smoker.pm:222:        return undef if ( (!defined $regex_list) || ($regex_list->size ==0));
lib/Tester/Smoker.pm:235:        my $regex_list = $self->load_regexes;
lib/Tester/Smoker.pm:236:        if (!defined $regex_list || $self->_update_regex) {
lib/Tester/Smoker.pm:237:            if ($self->fetch_and_save_regex()) {   # Retrieve regex from default source
lib/Tester/Smoker.pm:238:                $regex_list = $self->load_regexes; # and reload from database
lib/Tester/Smoker.pm:239:                $self->_update_regex(0);
lib/Tester/Smoker.pm:241:                $self->log->error("Failed to retrieve regex");
lib/Tester/Smoker.pm:247:            $self->sql->db->select(-from => 'releases',
lib/Tester/Smoker.pm:248:                                   -where => {id => {-in => $module_id}},
lib/Tester/Smoker.pm:250:                                  )->hashes;
lib/Tester/Smoker.pm:255:        $module_info->each( sub {
lib/Tester/Smoker.pm:256:                              my $module_id = $_->{id};
lib/Tester/Smoker.pm:257:                              my $regex_match = join('/', $_->{author}, $_->{name});
lib/Tester/Smoker.pm:259:                              $regex_list->each(sub {
lib/Tester/Smoker.pm:260:                                                  my $against = $_->{regex};
lib/Tester/Smoker.pm:263:                                                    if ($_->{disable}) {
lib/Tester/Smoker.pm:264:                                                      $disabled_by = $_->{origin};
lib/Tester/Smoker.pm:271:                              eval { $self->sql->db->update(-table => 'releases',
lib/Tester/Smoker.pm:272:                                                            -set => { disabled_by => $disabled_by },
lib/Tester/Smoker.pm:273:                                                            -where => { id => $module_id });
lib/Tester/Smoker.pm:274:                                     $self->log->info("Module $_->{name} disabled by regex")
lib/Tester/Smoker.pm:285:        if (ref $args->{release_id} eq 'Mojo::Collection') { # Flatten into array of id values
lib/Tester/Smoker.pm:286:            $args->{release_id} = $args->{module_id}->map(sub {$_->{id}})->to_array;
lib/Tester/Smoker.pm:288:        return $self->_check_regexes($args->{release_id});   # scalar or arrayref OK
lib/Tester/Smoker.pm:293:        $self->check_regex(release_id => $release_id);
lib/Tester/Smoker.pm:295:          $self->sql->db->select(-from => 'releases',
lib/Tester/Smoker.pm:296:                                 -columns => 'disabled_by',
lib/Tester/Smoker.pm:297:                                 -where => {id => $release_id})->hashes->first;
lib/Tester/Smoker.pm:299:        return defined $check ? $check->{disabled_by} : undef;
lib/Tester/Smoker.pm:308:        $self->sql->db->select(-from => 'environments',
lib/Tester/Smoker.pm:309:                               -where => $where,
lib/Tester/Smoker.pm:310:                               -limit => 1,
lib/Tester/Smoker.pm:311:                              )->hashes->first;
lib/Tester/Smoker.pm:323:        $self->sql->db->select(-from => 'releases',
lib/Tester/Smoker.pm:324:                               -where => $where,
lib/Tester/Smoker.pm:325:                               -limit => $limit // 1,
lib/Tester/Smoker.pm:326:                               -order_by => ['-released'])->hashes;
lib/Tester/Smoker.pm:338:        my $module_name = eval { $fields->{module}->[0]->{name}; } // $fields->{main_module};
lib/Tester/Smoker.pm:340:        # print STDERR "save: ".$fields->{main_module};
lib/Tester/Smoker.pm:344:            $self->sql->db->query('INSERT INTO releases(name, distribution, version, released, author, download_url) '.
lib/Tester/Smoker.pm:346:                                  $module_name, $fields->{main_module},
lib/Tester/Smoker.pm:348:            ->last_insert_id;
lib/Tester/Smoker.pm:350:        # print STDERR "->$id $! $@\n";
lib/Tester/Smoker.pm:359:        my $module_fields = $self->cpan->get_module_info($module_name, $type);
lib/Tester/Smoker.pm:361:            $module_fields->{_db_id} = $self->save_release_info($module_fields);  # keep new id value
lib/Tester/Smoker.pm:372:            $releases->each(sub {
lib/Tester/Smoker.pm:373:                                $_->{id} = eval {$self->sql->db->insert(-into => 'releases',
lib/Tester/Smoker.pm:374:                                                                        -values => {%$_{qw(name version
lib/Tester/Smoker.pm:376:                                                                                    distribution => $_->{main_module},
lib/Tester/Smoker.pm:378:                                                                                    released => $_->{date} =~ s/T/ /r,
lib/Tester/Smoker.pm:380:                                                                       )->last_insert_id;
lib/Tester/Smoker.pm:382:                                if (!defined $_->{id}) {  # Probably already existed
lib/Tester/Smoker.pm:383:                                    $_->{id} = eval { my $g = $self->sql->db->select(-from => 'releases',
lib/Tester/Smoker.pm:384:                                                                                     -where => {%$_{qw(name version)}});
lib/Tester/Smoker.pm:385:                                                      $g->hashes->first->{id};
lib/Tester/Smoker.pm:389:            $self->log->info("got updated release list");
lib/Tester/Smoker.pm:398:        return save_releases($self->cpan->get_modules($source));
lib/Tester/Smoker.pm:406:        return $self->update($self->cpan->module_list_url('recent', $source));
lib/Tester/Smoker.pm:413:        return $self->update($self->cpan->module_list_url('all', $source));
lib/Tester/Smoker.pm:418:        return $self->save_releases(Mojo::Collection->new($self->cpan->get_metacpan($args)));
lib/Tester/Smoker.pm:426:        # Choose only filled arguments: defined scalars, and non-empty arrays.
lib/Tester/Smoker.pm:427:        my $picked_args = {  $args->%{grep { ref $args->{$_} eq 'ARRAY' ? scalar @{$args->{$_}} : defined $args->{$_} } keys %{$args}}  };
lib/Tester/Smoker.pm:428:        my $results = eval { $self->sql->db->select( -from => 'releases',
lib/Tester/Smoker.pm:429:                                                     -where => $picked_args,
lib/Tester/Smoker.pm:430:                                                     -order_by => [qw(distribution author)],
lib/Tester/Smoker.pm:433:        return $results->hashes if defined $results; # a Mojo::Collection
lib/Tester/Smoker.pm:443:        my $our_tests = eval { $self->sql->db->select( -from => 'tests',
lib/Tester/Smoker.pm:444:                                                       -where => {release_id => $args->{id}}, # an array, so creates an IN... clause
lib/Tester/Smoker.pm:445:                                                       -columns => [qw(id release_id environment_id start_time elapsed_time grade report_sent)],
lib/Tester/Smoker.pm:446:                                                     )->hashes;
lib/Tester/Smoker.pm:450:            my $env = $self->get_environment({id => $_->{environment_id}});
lib/Tester/Smoker.pm:451:            $_->@{qw(archname perl osname osvers perlbrew)} = $env->@{qw(archname perl osname osvers perlbrew)};
lib/Tester/Smoker.pm:452:            $_->{distribution} = $args->{distribution};
lib/Tester/Smoker.pm:465:        my $u = Mojo::URL->new($self->config->{cpan}->{cpantesters_static});
lib/Tester/Smoker.pm:466:        push @{$u->path->parts}, substr($args->{distribution},0,1), $args->{distribution} =~ s/::/-/gr . '.json';
lib/Tester/Smoker.pm:467:        $u->path->trailing_slash(0);
lib/Tester/Smoker.pm:469:        my $results = Mojo::UserAgent->new->get($u);
lib/Tester/Smoker.pm:471:            $results = Mojo::JSON::decode_json($results->res->body);
lib/Tester/Smoker.pm:486:        my $our_tests = $self->get_local_tests($args);
lib/Tester/Smoker.pm:487:        # print Dumper($our_tests->to_array);
lib/Tester/Smoker.pm:488:        my $their_tests = $self->get_remote_tests($args);
lib/Tester/Smoker.pm:493:        # grep { $_->{version} eq '7.60' &&            # Module version
lib/Tester/Smoker.pm:494:        #      $_->{platform} eq $Config{archname} &&  # Matching our architecture, O.S., OS version (roughly),
lib/Tester/Smoker.pm:495:        #      fc($_->{osname}) eq fc($Config{osname}) &&
lib/Tester/Smoker.pm:496:        #      $match_osvers eq ($_->{osvers} =~ /^(\d+\.\d+)/, $1) &&
lib/Tester/Smoker.pm:497:        #      $_->{perl} eq $Config{version}          # and Perl version
lib/Tester/Smoker.pm:519:      # Similar to the hash slice, » $hash->%{@elements} «
lib/Tester/Smoker.pm:522:      return map { exists $hash->{$_} ? ( $_, $hash->{$_} ) : () } @elements;
lib/Tester/Smoker.pm:530:      my $release_id = $mod_info->{dist_id} // eval {
lib/Tester/Smoker.pm:531:        # Because of the index `dist_idx`, choosing the most-recent
lib/Tester/Smoker.pm:534:        # TODO: use $self->get_module_info() instead of db query here
lib/Tester/Smoker.pm:535:        $self->app->db->select( -from => 'releases',
lib/Tester/Smoker.pm:536:                                -columns => ['id'],
lib/Tester/Smoker.pm:537:                                -where => { _pick ( $mod_info,
lib/Tester/Smoker.pm:539:                                -order_by => ['-added'],
lib/Tester/Smoker.pm:540:                                -limit => 1 )->hash->{id};
lib/Tester/Smoker.pm:542:      $self->smoker->minion->enqueue('test', [{ dist_id => $release_id,
lib/Tester/Smoker.pm:543:                                               env_id => $mod_info->{environment_id}
lib/Tester/Smoker.pm:552:      #   _find_recent($self,{added => {'>',\["datetime('now', ?)", '-21 day']}})
lib/Tester/Smoker.pm:555:        $self->app->db->select( -from => 'releases',
lib/Tester/Smoker.pm:557:                                # guarantees we get the most-recently-added version
lib/Tester/Smoker.pm:559:                                -columns => ['id', 'name', 'max(added) as added'],
lib/Tester/Smoker.pm:560:                                -where => { _pick ( $mod_info,
lib/Tester/Smoker.pm:564:                                -group_by => ['name'],
lib/Tester/Smoker.pm:565:                                -order_by => ['-added'], # most-recent first
lib/Tester/Smoker.pm:566:                                (defined $limit) ? (-limit => $limit) : (),
lib/Tester/Smoker.pm:568:      return $releases->hashes; # as a Mojo::Collection
lib/Tester/Smoker.pm:573:      return _find_recent($self,{added => {'>',\["datetime('now', ?)", -$day_count.' days']}}, $limit);
lib/Tester/Smoker.pm:586:            $command_info->{$_ . '_command'} = $info->{$_.'_exit'}->{command};
lib/Tester/Smoker.pm:587:            $command_info->{$_ . '_error'}= join("\n\n",grep {defined}            # Condense:
lib/Tester/Smoker.pm:588:                                                 ( $info->{$_.'_exit'}->{stderr}, # full error log
lib/Tester/Smoker.pm:589:                                                   $info->{$_.'_exit'}->{error},  # explanation of process exit code
lib/Tester/Smoker.pm:598:        # this should be stored per-test.  Use something like this:
lib/Tester/Smoker.pm:604:        # environment id" when the test-run was dequeued, and the
lib/Tester/Smoker.pm:607:        my $test_id = eval { $self->sql->db->insert(-into => 'tests',
lib/Tester/Smoker.pm:608:                                                    -values => {%{$info}{
lib/Tester/Smoker.pm:615:                                                    )->last_insert_id; };
lib/Tester/Smoker.pm:625:        my $release_id = $args->{release_id};
lib/Tester/Smoker.pm:626:        my $env_id = $args->{environment};
lib/Tester/Smoker.pm:632:            $self->log->error($error);
lib/Tester/Smoker.pm:633:            $minion_job->fail($error);
lib/Tester/Smoker.pm:637:        my $module_info = $self->sql->db->select(-from => 'releases',
lib/Tester/Smoker.pm:638:                                                 -where => {id => $release_id}
lib/Tester/Smoker.pm:639:                                                )->hashes;
lib/Tester/Smoker.pm:641:        $module_info = $module_info->first;
lib/Tester/Smoker.pm:644:        my $dis_by = $self->release_disabled_by($release_id);
lib/Tester/Smoker.pm:647:            $self->log->warn($error);
lib/Tester/Smoker.pm:648:            $minion_job->fail($error);
lib/Tester/Smoker.pm:652:        if (!defined $module_info->{name} || !defined $module_info->{version}) {
lib/Tester/Smoker.pm:654:            $self->log->warn($error);
lib/Tester/Smoker.pm:655:            $minion_job->fail($error);
lib/Tester/Smoker.pm:659:        $self->log->info("Testing: $module_info->{name} version $module_info->{version}");
lib/Tester/Smoker.pm:664:        ### http://www.dagolden.com/index.php/2098/the-annotated-lancaster-consensus
lib/Tester/Smoker.pm:675:             $env_id = $self->my_environment();
lib/Tester/Smoker.pm:678:        my $pb = eval { $self->sql->db->select(-from => 'environments',
lib/Tester/Smoker.pm:679:                                               -where => {id => $env_id})->hashes->first; };
lib/Tester/Smoker.pm:682:            $self->log->error($error_msg);
lib/Tester/Smoker.pm:683:            $minion_job->fail($error_msg);
lib/Tester/Smoker.pm:687:            my $log_msg = "Using Perl version ".$pb->{perl};
lib/Tester/Smoker.pm:688:            $log_msg .= ", Perlbrew installation ".$pb->{perlbrew} if defined $pb->{perlbrew};
lib/Tester/Smoker.pm:689:            $self->log->info($log_msg);
lib/Tester/Smoker.pm:692:        my $result = $self->tester->run({module => $module_info->{download_url},
lib/Tester/Smoker.pm:696:            my $log_msg = 'Test complete, '. $module_info->{name} .' ->';
lib/Tester/Smoker.pm:697:            $log_msg .= ' grade='.$result->{grade} if defined $result->{grade};
lib/Tester/Smoker.pm:698:            $log_msg .= ' elapsed time='. $result->{elapsed_time} if defined $result->{elapsed_time};
lib/Tester/Smoker.pm:699:            $log_msg .= ' ...Error='.$result->{test_exit}->{error} if defined $result->{test_exit}->{error};
lib/Tester/Smoker.pm:700:            $self->log->info($log_msg);
lib/Tester/Smoker.pm:701:            $minion_job->finish($log_msg);
lib/Tester/Smoker.pm:705:        $self->log->info("enqueueing Report");
lib/Tester/Smoker.pm:707:        my $test_id = $self->save_test({release => $module_info->{name},
lib/Tester/Smoker.pm:716:                                        # minion_job => $minion_job->info->{id},
lib/Tester/Smoker.pm:719:        $minion_job->note(test_id => $test_id);
lib/Tester/Smoker.pm:720:        $minion_job->note(command => $command) if defined $command;
lib/Tester/Smoker.pm:722:        my $test_error = $result->{test_exit}->{stderr};
lib/Tester/Smoker.pm:728:        $minion_job->minion->enqueue(report => [{test_id => $test_id,
lib/Tester/Smoker.pm:731:                                                 duration => $result->{elapsed_time},
lib/Tester/Smoker.pm:734:                                     {queue => $self->report_queue,
lib/Tester/Smoker.pm:735:                                      parents => [$minion_job->info->{id}]});
lib/Tester/Smoker.pm:736:        $self->log->info("Report enqueued");
lib/Tester/Smoker.pm:743:        if ( $exit == -1 ) {
lib/Tester/Smoker.pm:744:            $self->log->error ("$what failed to execute: $!");
lib/Tester/Smoker.pm:746:            $self->log->error( sprintf("$what child died with signal %d, %s coredump\n",
lib/Tester/Smoker.pm:749:            $self->log->info(sprintf("$what child exited with value %d\n", $exit >> 8));
lib/Tester/Smoker.pm:759:        my $result = eval { $self->sql->db->query(
lib/Tester/Smoker.pm:761:                                             $test_id)->hashes->first; };
lib/Tester/Smoker.pm:773:        #my $result = eval { $self->sql->db->select(-from => 'tests',
lib/Tester/Smoker.pm:774:        #                                           -columns =>
lib/Tester/Smoker.pm:775:        my $result = eval { $self->sql->db->query("select (select perlbrew from environments where id=environment_id) as perlbrew, (select distribution from releases where id=release_id) as distribution, (select version from releases where id=release_id) as version, datetime(start_time,'unixepoch') as timestamp, elapsed_time, grade from tests;")->hashes; };
lib/TestModule.pm:4:use Mojo::Base '-base';
lib/TestModule.pm:15:    my $cf = CPAN::Testers::Common::Client::Config->new;
lib/TestModule.pm:16:    $cf->read;
lib/TestModule.pm:21:has 'perlbrew' => 'perlbrew exec --with';
lib/TestModule.pm:23:has 'cpanm_test' => 'cpanm --test-only';
lib/TestModule.pm:24:has 'local_lib';    # If set, use '-L' and this to keep test
lib/TestModule.pm:33:    return defined $self->config->email_from;
lib/TestModule.pm:42:    return (defined $perl_release) ? join(' ',$self->perlbrew, $perl_release, $command) : $command;
lib/TestModule.pm:50:    my $email = $self->config->email_from;
lib/TestModule.pm:54:    my $temp_dir_name = File::Temp->newdir;
lib/TestModule.pm:56:    my $module       = $params->{module};
lib/TestModule.pm:57:    my $perl_release = $params->{perl_release};
lib/TestModule.pm:61:    # http://www.dagolden.com/index.php/2098/the-annotated-lancaster-consensus
lib/TestModule.pm:68:    my @cpanm_args = ($self->cpanm_test);
lib/TestModule.pm:69:    if ($self->local_lib) {  # This is the root of the local_libs
lib/TestModule.pm:70:        my $use_lib = Mojo::File->new($self->local_lib);
lib/TestModule.pm:71:        $use_lib->child($perl_release) if defined $perl_release; # Specific to version
lib/TestModule.pm:72:        push @cpanm_args, '-L', $use_lib;
lib/TestModule.pm:77:    my $cpanm_test_command = $self->with_perl(join(' ', @cpanm_args), $perl_release);
lib/TestModule.pm:80:    $self->log->info("Shelling to: $cpanm_test_command") if (defined $self->log);
lib/TestModule.pm:82:    my $test_exit = $self->check_exit( $cpanm_test_command );
lib/TestModule.pm:85:    my $build_file = Mojo::File->new($temp_dir_name)->child('build.log');
lib/TestModule.pm:88:    # cpanm-reporter will put its report in the directory indicated by
lib/TestModule.pm:93:    # cpanreporter and cpanm-reporter; set env to force its use
lib/TestModule.pm:94:    my $config_file = Mojo::File->new($temp_dir_name)->child('config.ini');
lib/TestModule.pm:95:    $config_file->spurt(<<CONFIG);
lib/TestModule.pm:101:    local $ENV{PERL_CPAN_REPORTER_CONFIG} = $config_file->to_string;
lib/TestModule.pm:108:      "cpanm-reporter --verbose "
lib/TestModule.pm:109:      . "--build_dir=$temp_dir_name "
lib/TestModule.pm:110:      . "--build_logfile=$build_file "
lib/TestModule.pm:111:      . "--skip-history --ignore-versions --force ";
lib/TestModule.pm:112:    my $reporter_exit = $self->check_exit( $self->with_perl($cpanm_reporter_command, $perl_release) );
lib/TestModule.pm:115:    # ${temp_dir_name}/{Status}.{module_name}-{build_env_stuff}.{timestamp}.{pid}.rpt
lib/TestModule.pm:117:    my $test_results = Mojo::File->new($temp_dir_name)->list_tree;
lib/TestModule.pm:120:    my $report_file = $test_results->map(
lib/TestModule.pm:133:    if ( $report_file->size ) {    # Report file exists.  Extract grade and contents.
lib/TestModule.pm:134:        $report_filename = $report_file->[0]->to_string;
lib/TestModule.pm:135:        $grade           = $report_file->[1];
lib/TestModule.pm:136:        $report_contents = Mojo::File->new($report_filename)->slurp
lib/TestModule.pm:137:          if ( -e $report_filename );
lib/TestModule.pm:142:            build_log => $build_file->slurp,   # …from above
lib/TestModule.pm:179:    # -1 means failure to execute the command at all
lib/TestModule.pm:187:    $status->{stderr} = $stderr if defined $stderr;
lib/TestModule.pm:188:    $status->{command} = $command;
lib/TestModule.pm:189:    $status->{signal_received} = $signal_received if defined $signal_received;
lib/TestModule.pm:192:    if ( $exit == -1 ) {
lib/TestModule.pm:193:        $status->{error} = "Failed to execute: $!";
lib/TestModule.pm:195:        $status->{error} = sprintf(
lib/TestModule.pm:201:        $status->{error} = sprintf( "Child exited with value %d", $exit >> 8 );
lib/TestModule.pm:203:    $self->log->warn($status->{command} . ' --> ' . $status->{error}) if defined $self->log;
smoketest.conf:15:          # exists under {author}/CPAN-{version}/distroprefs/ in the
smoketest.conf:19:          # For downloading the full, or most-recent-list of modules.
smoketest.conf:24:          # File containing list of most-recently added/updated modules
smoketest.conf:26:          #    '01modules.index.html'    Version release dates, slower DOM-based loop
smoketest.conf:36:  smoker => { # perlbrew => 'perlbrew exec --with',  # always followed by the perlbrew version desired
smoketest.conf:37:              cpanm_test => 'cpanm --test-only --configure-timeout 5 --build-timeout 5 --test-timeout 5',
smoketest.conf:38:              local_lib => '/tmp/perl_libs',         # If set, will be prefixed by '-L' for cpanm command
sqlite_migrations:1:-- 1 down
sqlite_migrations:11:-- 1 up
sqlite_migrations:15:                      name TEXT NOT NULL,         -- e.g., 'Mojolicious-7.60'
sqlite_migrations:16:                      version TEXT NOT NULL,      -- e.g., '7.60' NOTE: Freeform text!
sqlite_migrations:17:                      released TIMESTAMP,  -- version timestamp
sqlite_migrations:27:-- For storing the complex regexps that will be applied to module names,
sqlite_migrations:28:-- thereby determining which modules are enabled and disabled.
sqlite_migrations:32:                           priority INTEGER, -- lower values take higher precedence
sqlite_migrations:33:                           disable  INTEGER, -- enable (0) or disable (1) the modules in the regex
sqlite_migrations:34:                           origin TEXT,  -- URL or filename
sqlite_migrations:35:                           regex  TEXT,  -- Regular expression to match module names against
sqlite_migrations:36:                           author TEXT,  -- PAUSE identifier
sqlite_migrations:44:                           host TEXT,         -- Hostname (preferably full name; 'localhost' is less helpful)
sqlite_migrations:45:                           perlbrew TEXT,     -- Version name we pass to Perlbrew
sqlite_migrations:46:                           -- These (platform, perl, osname, osvers) match fields in Testers Metabase
sqlite_migrations:47:                           -- See https://github.com/barbie/cpan-testers-data-generator/
sqlite_migrations:49:                           perl       TEXT,   -- Perl version, $Config{version}
sqlite_migrations:50:                           osname     TEXT,   -- from $Config{osname}
sqlite_migrations:51:                           osvers     TEXT,   -- $Config{osvers}
sqlite_migrations:52:                           archname   TEXT,   -- $Config{archname}
sqlite_migrations:60:                    release_id INTEGER,       -- UUT [unit under test]
sqlite_migrations:61:                    environment_id INTEGER,   -- replaces perl_build
sqlite_migrations:62:                    -- Data from TestModule:
sqlite_migrations:63:                    start_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP, -- when testing began (was enqueued)
sqlite_migrations:72:                    report_sent TIMESTAMP,      -- When submitted to remote
sqlite_migrations:77:-- 2 up
sqlite_migrations:79:ALTER TABLE releases ADD COLUMN distribution TEXT;      -- e.g., 'Mojo::Pg'
README.md:13:http://blogs.perl.org/users/preaction/2017/07/cpan-testers-has-an-api.html
README.md:23:    package built-in.
README.md:35:Source: http://neilb.org/2015/09/05/cpan-glossary.html
README.md:40:    $ sudo apt install sqlite3 libssl-dev zlib1g-dev
README.md:61:    - the `local_lib` parameter in `smoker`, if set, will append the
README.md:62:      `-L` switch to the cpanm invocation, along with the value given,
README.md:66:      `--test-only` from each base Perlbrew installation.
README.md:84:    -v                    Verbose mode
README.md:85:    --count=10            How many releases to retrieve from MetaCPAN
README.md:86:    --distribution=Name   Specify a particular distribution to test
README.md:87:    --dist=Name           (abbreviation for --distribution)
README.md:88:    --version=0.9         Which version of the above distribution to test
README.md:89:    --release=Name-0.9    Combine distribution and version into
README.md:91:    --author=PREACTION    Specify an author
README.md:92:    --start_date=2017-01-01  Specify a starting date
README.md:93:    --end_date=2017-01-01 Specify an end date
README.md:94:    --perl_version=5.26.1 Specify one or more Perl versions
README.md:96:    --force               Force testing even of releases
README.md:98:    --notest              Do not enqueue any test jobs,
README.md:101:Unless --distribution or --release is specified, only the latest
README.md:104:---
README.md:118:---
README.md:127:    $ ./smoketest daemon -l http://*:8080
README.md:129:---
README.md:138:     $ ./smoketest minion -s               # shows overall status
README.md:139:     $ ./smoketest minion job -S inactive  # shows queued jobs
README.md:140:     $ ./smoketest minion job -S finished  # shows completed jobs
README.md:160:---
README.md:167:    $ ./smoketest list -r
README.md:172:    1729  inactive  App-abgrep-0.003                   0.003          pass
README.md:173:    1728  inactive  CSS-DOM-0.17                       0.17           pass
README.md:174:    1727  inactive  Test-Time-HiRes-0.01               0.01           pass
README.md:178:    $ ./smoketest release -count 3
README.md:185:---
README.md:203:---
README.md:212:---
README.md:214:NOTE: On running the cpanm-reporter command for first time, it asks a
TODO:3:- Configurable timeout.  Revisit TestModule.pm to re-enable this
TODO:6:- When release grade is null, in most cases these reports should not
TODO:12:- improve dashboard at project web root to include statistics and
TODO:17:- Add a parameter to the 'update' endpoint to permit also enqueueing a
TODO:23:- Modify how we call Capture::Tiny to send output to some sort of web
TODO:27:- Continue integration with improvements to CPAN::Testers::API
TODO:29:- Update the Yancy configuration with `type => 'textarea'` for
TODO:30:  multi-line fields.
TODO:32:- Future: Update the Yancy configuration with extended field
TODO:35:  view the combined log, the STDERR-only error log, and other data in
TODO:38:---
TODO:44:  - a group of modules, or
TODO:45:  - main programs (with associated cpanfiles like Carton), or
TODO:46:  - a private repository (like a subset mirror of cpan)
TODO:51:Can this be integrated with an automated build or continuous-
TODO:52:integration system so that entire applications can be "pre-flight"
TODO:56:2018-01-11 with Doug, Ray
TODO:70:dependencies: cpan-sysdeps -- mapping to cpan modules, packages,
TODO:89:in sub summary ($c) { ... } we add the validation->param(...)
TODO:95:2018-01-24
TODO:97:To enqueue a job with Held status, e.g., the Reports --
TODO:99:  - enqueue a job in an alternate queue ('hold' queue)
TODO:100:  - make the target job a child of that held job (set parent to other job's id)
TODO:111:---begin---
TODO:114:$u = Mojo::UserAgent->new->get('http://www.cpantesters.org/static/distro/M/Mojolicious.json');
TODO:115:$j = Mojo::JSON::decode_json($u->res->body);
TODO:122:grep { $_->{version} eq '7.60' &&            # Module version
TODO:123:     $_->{platform} eq $Config{archname} &&  # Matching our architecture, O.S., OS version (roughly),
TODO:124:     fc($_->{osname}) eq fc($Config{osname}) &&
TODO:125:     $match_osvers eq ($_->{osvers} =~ /^(\d+\.\d+)/, $1) &&
TODO:126:     $_->{perl} eq $Config{version}          # and Perl version
TODO:129:---end---
TODO:136:   sqlite> select distinct(substr(distribution,1,1)||'/'||replace(distribution,'::','-')) from releases;
TODO:142:Match each entry in the json where $_->{distversion} is e.g.,
TODO:143:'JMAP-Tester-0.016' against our database's releases.name column
TODO:155:releases within last 2 days --? izzit true?
TODO:157:curl -XPOST 'https://fastapi.metacpan.org/v1/file' -d "$(curl -Ls gist.github.com/metacpan-user/5705999/raw/body.json)"
TODO:161:---begin---
TODO:181:                "gte" : "now-2d/d",
TODO:193:---end---
TODO:197:---begin---
TODO:199:---end---
smoketest:28:# ./smoketest release --author PREACTION --count 5 \
smoketest:29:#   --start_date=2012-07-01 --end_date=2012-12-30
smoketest:38:    has 'description' => 'Release a currently-enqueued report';
smoketest:43:Usage: APPLICATION release [IDS] [-count N]
smoketest:56:        my $jobs = $self->app->minion->backend->list_jobs(0, scalar @args || $count // 50,  # offset, limit
smoketest:62:        foreach my $job (@{$jobs->{jobs}}) {
smoketest:64:            my ($id, $retries) = $job->@{qw(id retries)};  # array slice from hash
smoketest:66:            if ($self->app->minion->backend->retry_job($id, $retries, {queue => 'default'})) {
smoketest:67:                $self->app->log->info("Released report job $id");
smoketest:69:                $self->app->log->error("Failed to release job $id");
smoketest:83:    has 'description' => 'List currently-enqueued tests to be run';
smoketest:88:Usage: APPLICATION list [state] [-count N] [-reports]
smoketest:103:        my $jobs = $self->app->minion->backend->list_jobs(0, $count // 50,  # offset, limit
smoketest:114:                                            my $release_id = eval{$_->{args}->[0]->{'release_id'}};
smoketest:116:                                                my $info = $self->app->smoker->get_release_info({id => $release_id}) if defined $release_id;
smoketest:117:                                                if (!defined $info || !$info->size) {
smoketest:120:                                                    [ $_->{id}, $_->{state},
smoketest:121:                                                      $info->first->@{qw/name version/},
smoketest:122:                                                      $_->{notes}->{perl_version} // '',
smoketest:123:                                                      eval{$_->{args}->[0]->{'grade'}} // '(unknown)',
smoketest:130:                                        @{$jobs->{jobs}} ];
smoketest:135:                                                [ $_->{id}, $_->{notes}->{perl_version},
smoketest:136:                                                  $_->{result}
smoketest:139:                                            @{$jobs->{jobs}} ];
smoketest:143:                                                my $release_id = eval{$_->{args}->[0]->{'release_id'}};
smoketest:145:                                                    my $info = $self->app->smoker->get_release_info({id => $release_id}) if defined $release_id;
smoketest:146:                                                    if (!defined $info || !$info->size) {
smoketest:149:                                                        [ $_->{id}, $_->{state},
smoketest:150:                                                          $info->first->@{qw/name version author/},
smoketest:151:                                                          $_->{notes}->{perl_version} // '',
smoketest:158:                                            @{$jobs->{jobs}} ];
smoketest:178:   -s something
smoketest:184:        return $self->app->smoker->fetch_and_save_regex(@args);
smoketest:198:        my $updated_releases = $self->app->smoker->get_all(@args);
smoketest:199:        if ($self->app->smoker->check_regex(release_id => $updated_releases)) {
smoketest:200:            $self->app->log->info("modules updated OK");
smoketest:202:            $self->app->log->error("could not update module list");
smoketest:218:Usage: APPLICATION update [-v|--verbose] [-count=N] [-force] [-notest] [--distribution=DIST]
smoketest:219:                          [--version=N.NN] [--release=N] [--author=N] [--perl_version=N]
smoketest:220:                          [--start_date=YYYY-MM-DD] [--end_date=YYYY-MM-DD]
smoketest:229:          'v|verbose' => \my $verbose,   # Note abbrev, versus -version below
smoketest:234:          'version=s' => \my @versions,  # one 'Release' is a 'Distribution-Version' combination,
smoketest:241:        # Split/join to also permit comma-delimited
smoketest:243:          $self->app->smoker->get_metacpan( { count => $count,
smoketest:253:        $self->app->smoker->update_perl_versions(@args);
smoketest:257:            # Look for Perlbrew name first, then Perl's self-reported version
smoketest:258:            my $vv = $self->app->smoker->get_environment({perlbrew => $v}) //
smoketest:259:                $self->app->smoker->get_environment({perl => $v});
smoketest:268:          @perl_test_versions = ($self->app->smoker->get_environment({id => $self->app->smoker->my_environment()}));
smoketest:272:          $self->app->log->info('Enqueueing ' . $releases->size . ' releases') if $verbose;
smoketest:273:          $releases->each(sub {
smoketest:274:                            my $id = $_->{id};
smoketest:279:                                # https://metacpan.org/pod/DBD::SQLite#Add-zero-to-make-it-a-number
smoketest:282:                                    $skip = eval{$self->app->sql->db->query(q{SELECT id FROM minion_jobs WHERE }.
smoketest:286:                                                                            $id, $v->{id})->hashes->first->{id}};
smoketest:287:                                    $skip //= eval{$self->app->sql->db->select(-from => 'tests',
smoketest:288:                                                                               -where => {release_id => $id,
smoketest:290:                                                   ->hashes->first->{id}};
smoketest:293:                                $self->app->log->info('  ... ' . $_->{name} .
smoketest:294:                                                      ' (Perl ' . ($v->{perlbrew} // $v->{perl}) . ')' .
smoketest:298:                                    $self->app->minion->enqueue(test => [{release_id => $id, environment => $v->{id}}],
smoketest:300:                                                                           perl_version => ($v->{perlbrew} // $v->{perl})
smoketest:312:# Force immediate in-this-thread execution of Minion jobs
smoketest:322:        if (!$self->app->smoker->tester->verify) {
smoketest:323:            die "Cannot run tests. (Have you configured an email address for cpanm-reporter?)"
smoketest:325:        $self->app->minion->perform_jobs();
smoketest:340:      state $smoker = Tester::Smoker->new(database => $self->app->config->{dbname},
smoketest:341:                                          config   => $self->app->config,
smoketest:342:                                          log      => $self->app->log,
smoketest:361:        my $result = eval { $self->app->db->query('SELECT * FROM tests WHERE id=?',$id)->hashes; };
smoketest:363:            print eval{$result->[0]->{build_log}}."\n";
smoketest:380:          'v|verbose' => \my $verbose,   # Note abbrev, versus -version below
smoketest:383:          'version=s' => \my @versions,  # one 'Release' is a 'Distribution-Version' combination
smoketest:389:        my $releases = $self->app->smoker->get_releases( { distribution => \@dists,
smoketest:396:                                    map { [$_->@{qw(id distribution version author)}] } @{$releases} ];
smoketest:402:            push @{$release_ids{$rel->{distribution}}}, $rel->{id};
smoketest:406:            $self->app->smoker->compare_tests({distribution => $_, id => $release_ids{$_}});
smoketest:417:app->secrets(['Get your fresh smoked red-hot modules here!']);
smoketest:420:push @{app->commands->namespaces}, 'main::Command';
smoketest:427:    state $smoker = Tester::Smoker->new(database => $self->config->{dbname},
smoketest:428:                                        config   => $self->config,
smoketest:429:                                        log      => $self->app->log,
smoketest:440:                                        app => $self->app,
smoketest:444:        $smoker->tester->$conf_val($self->config->{smoker}->{$conf_val})
smoketest:445:          if defined $self->config->{smoker}->{$conf_val};
smoketest:453:    state $sql = $self->smoker->sql;
smoketest:458:    state $db = $self->sql->db;
smoketest:461:plugin Minion => {SQLite => 'sqlite:'. app->config->{dbname}};
smoketest:463:# print STDERR app->config->{dbname} . "\n";
smoketest:465:                   backend => 'sqlite:'. app->config->{dbname},
smoketest:468:                                                    'x-list-columns' => [ qw(id queue state priority created) ],
smoketest:473:                                                                                 format => 'date-time',
smoketest:477:                                                                                  format => 'date-time',
smoketest:501:                                                 'x-list-columns' => [ qw(id name version author released) ],
smoketest:514:                                                                               format => 'date-time',
smoketest:527:                                                                            format => 'date-time',
smoketest:534:                                                     'x-list-columns' => [qw(id perlbrew perl osname osvers archname added)],
smoketest:567:                                                                                format => 'date-time',
smoketest:574:                                              'x-list-columns' => [qw(id release_id start_time elapsed_time grade)],
smoketest:587:                                                                              # format => 'date-time',
smoketest:610:                                                                                description => 'Command-line used when running test',
smoketest:618:                                                                                    description => 'Command-line used when running reporter',
smoketest:626:                                                                               format => 'date-time',
smoketest:637:app->minion->add_task( test => sub { my ($job, @args) = @_;
smoketest:638:                                     my ($result, @result_args) = $job->app->smoker->test($job, @args);
smoketest:640:                                         $job->finished(@result_args);
smoketest:642:                                         $job->fail(@result_args);
smoketest:645:                                         # $job->retry(@result_args);
smoketest:652:    my $result = eval { $self->db->query('SELECT COUNT(*) AS count FROM releases')->hashes->first; };
smoketest:654:        $self->render(json => $result);
smoketest:656:        $self->render(json => {error => 'Database not configured or not populated'});
smoketest:663:    # /release/Mojolicious-7.58
smoketest:664:    my $result = eval { $self->db->query('SELECT * FROM releases WHERE name=?',
smoketest:665:                                         $self->stash('release'))->hashes->first; };
smoketest:667:        $self->render(json => $result);
smoketest:669:        $self->render(json => {error => 'Release not found'});
smoketest:677:    my $result = eval { $self->db->query('SELECT * FROM releases WHERE distribution=?',
smoketest:678:                                         $self->stash('dist'))->hashes; };
smoketest:680:        $self->render(json => $result);
smoketest:682:        $self->render(json => {error => 'Distribution not found'});
smoketest:689:    my $result = eval { $self->db->query('SELECT * FROM releases WHERE author=?',
smoketest:690:                                         $self->stash('auth'))->hashes; };
smoketest:692:        $self->render(json => $result);
smoketest:694:        $self->render(json => {error => 'Distribution not found'});
smoketest:701:    my $result = $self->smoker->get_all_tests();
smoketest:704:        $self->render(json => $result);
smoketest:706:        $self->render(json => {error => 'Tests not found'});
smoketest:715:    my $test = $self->smoker->report_for($self->stash('id'));
smoketest:717:        $self->render(json => {error => 'Report not found'});
smoketest:720:    $self->render(json => $self->smoker->testersdb->report_json($test));
smoketest:723:app->minion->add_task ( report => sub { my ($job, @args) = @_;
smoketest:730:                                        my $test_release_id = $args[0]->{release_id};
smoketest:731:                                        my $test = $job->app->smoker->report_for($test_release_id)
smoketest:733:                                        my $test_json = $job->app->smoker->testersdb->report_json($test);
smoketest:734:                                        my $result = $job->app->smoker->testersdb->submit_report($test_json)
smoketest:738:                                            $job->finish($result);
smoketest:740:                                            $job->fail({error => 'Failed to submit report', %{$result}})
smoketest:750:    my $result = eval { $self->db->query('SELECT * FROM tests WHERE release_id in (SELECT id FROM releases WHERE name=?)',
smoketest:751:                                         $self->stash('release'))->hashes; };
smoketest:753:        $self->render(json => $result);
smoketest:755:        $self->render(json => {error => 'No tests have been run, or Distribution not found'});
smoketest:762:    my $result = eval { $self->db->query('SELECT * FROM tests WHERE release_id in (SELECT id FROM releases WHERE distribution=?)',
smoketest:763:                                         $self->stash('distribution'))->hashes; };
smoketest:765:        $self->render(json => $result);
smoketest:767:        $self->render(json => {error => 'No tests have been run, or Distribution not found'});
smoketest:774:    my $result = eval { $self->db->query('SELECT * FROM tests WHERE id=?',
smoketest:775:                                         $self->stash('id'))->hashes; };
smoketest:777:        $self->respond_to(json => {json => $result},
smoketest:778:                          html => {text => '<pre>'.eval{$result->[0]->{build_log}}.'</pre>'},
smoketest:779:                          any => {text => eval{$result->[0]->{build_log}}});
smoketest:781:        $self->render(json => {error => 'Test not found'});
smoketest:785:app->minion->add_task ( update => sub { my ($job, @args) = @_;
smoketest:786:                                                my $results = $job->app->smoker->get_recent(@args);
smoketest:788:                                                    $job->finished();
smoketest:790:                                                    $job->fail('Could not download updates list')
smoketest:797:    my $id = $self->minion->enqueue('update', {priority => 0});
smoketest:798:    $self->render(json => {job => {task => 'update', id => $id}});
smoketest:803:    my $id = $self->minion->enqueue('update' => [$self->stash('uri')], {priority => 0});
smoketest:804:    $self->render(json => {job => {task => 'update', id => $id}});
smoketest:809:    my $job = $self->minion->job($self->stash('id'));
smoketest:810:    $self->render(json => $job->info);
smoketest:815:    my $deleted = $self->minion->job($self->stash('id'))->remove;
smoketest:816:    $self->render(json => {success => $deleted});
smoketest:821:    my $stats = $self->minion->stats;
smoketest:822:    $self->render(json => $stats);
smoketest:825:app->start;
